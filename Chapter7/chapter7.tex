%*******************************************************************************
%****************************** Sixth Chapter *********************************
%*******************************************************************************

\chapter{Analysis of LISP mobility and ns-3 Implementation}
\label{cha:ns-3}

% **************************** Define Graphics Path **************************
\ifpdf
    \graphicspath{{Chapter7/Pics/Raster/}{Chapter7/Pics/PDF/}{Chapter7/}}
\else
    \graphicspath{{Chapter7/Pics/Vector/}{Chapter7/}}
\fi

%-< ABSTRACT >--------------------------------------------------------------------
The \emph{Locator/Identifier Separation Protocol} (LISP) reconstructs the current IP addressing space so to achieve the seamless mobility. LISP Mobile Node (LISP-MN) is based on the basic LISP functionality to provide seamless mobility across networks. Thus, LISP can be implemented either on the border routers or directly on the end hosts to manage mobility. However, there are no experimental results comparing the advantages and disadvantages of each solution. The basic LISP architecture is deployed on LISP Beta Network and LISP-Lab platform to offer the researchers a realistic experimental environment, but both do not support LISP-MN. Some simulation models with LISP extensions are implemented on various simulators, but are not open source. Fortunately, there is an open source project implementing the fundamental LISP on ns-3 in 2016. Providing a free and flexible LISP simulator so to help researchers quickly test new LISP mobility behaviors motivates our work. This chapter analyzes the different LISP mobility scenarios from the respects of handover delay and overhead of control plane. It describes the characteristics of each scenario. In addition, this chapter introduces the implementation of basic LISP architecture model and LISP-MN on the simulator ns-3. % It also provides the evaluation results in mobility scenario to validate the model and shows when the current proposal of LISP-MN is behind a LISP-site has a very high delay during the handover procedure.

The rest of chapter is organized as follows: Sec.~\ref{sec:ns3_related_work} introduces ns-3 and the existing LISP simulator on it. Sec.~\ref{sec:ns3_lispmn} analyzes the design and implementation of our prototype, and afterwards, Sec.~\ref{sec:ns3_analysis} illustrates three different LISP scenarios supporting seamless mobility, presents their traffic schema, modelizes the handover delay and overhead of control plane, and compares their advantages and disadvantages. % Sec.~\ref{sec:evaluation} presents preliminary evaluation results of our implementations. 
Sec.~\ref{sec:ns3_conclusion} provides some ideas of evaluation based on the proposed simulation for future work.
%-< ABSTRACT >--------------------------------------------------------------------

%%-< SECTION >--------------------------------------------------------------------
%\section{Related work}
%\label{sec:ns3_related_work}
\section{NS-3}
\label{sec:ns3_ns3}
ns-3~\cite{ns3} is a popular and free discrete-event network simulator for networking research. It is developed completely in the C++ programming language. %, because it better facilitated the inclusion of C-based implementation code. 
The ns-3 architecture is similar to Linux computers with application, TCP/IP protocol stack, network interface, sockets, etc. ns-3 is very well documented and has an active community which facilitate the researches to adapt ns-3 source code for their researches.  Besides, ns-3 offers the possibility to visualize the simulation instance so to allow the users to visually confirm the packets flow as they expect. 
%\begin{itemize}
%    \item Description of ns-3.
%    \item The simulator supporting LISP is introduced in Sec.~\ref{subsec:implementation_OMNet}.
%\end{itemize}

%-< SUB SECTION >--------------------------------------------------------------------
\section{Basic LISP implementation on ns-3}
\label{sec:ns3_basic_lisp}
Simulation is becoming more important for deploying new technologies or as a proof of concept of new protocols. In the study of LISP, there exist few simulators based on OMNet++~\cite{vesely2015locator, vesely2014multicast, klein2012integration} or based on Java~\cite{stockmayer2016jlisp}. However, these existing simulators are not open-source, which hinders other researchers to modify or adapt the simulator with respect to their own research purposes.

To our best knowledge, the unique open-source LISP simulator that we found in the literature is the one proposed by Agbodjan~\cite{lionel2016}. The authors implemented a basic LISP simulator\footnote{The source code is available at \url{https://bitbucket.org/Lionel_Agbodjan/tfe__towards_a_lisp_simulator}}\yue{ugly} under ns-3.24, but this work can be further polished. For example, the encoding of LISP control plane messages do not respect RFC 6830~\cite{rfc6830} so that the Wireshark~\cite{wireshark} can not resolve the captured results in the correct format. % and there exist some bugs when using this simulator. 
More importantly, its implementation has no support for LISP mobility. % Our implementation work is inspired by work of~\cite{lionel2016}. 
By leveraging the source code of Agbodjan, we implement an open source LISP simulator with LISP mobility extension under ns-3.27, which is the latest ns-3 version. 

 
%-< SECTION >--------------------------------------------------------------------
\section{ LISP mobility extensions on ns-3}
\label{sec:ns3_lispmn}
Our implementation respects LISP RFC 6830~\cite{rfc6830} and LISP mobility standards~\cite{meyer2016lisp}. As a design choice, we implement LISP and LISP mobility functionalities by modifying and extending two already existing modules of ns-3:~\emph{internet} and \emph{internet-apps}, instead of by creating a new independent module. The justification behind this design is that LISP protocol and legacy Internet module have an interdependent relationship: an IP layer packet is processed by LISP and then passed to IP protocol again. However, this kind mutually dependent relationship between modules is not supported by ns-3. Our implementation consists of two parts: LISP Data plane and LISP Control plane. The communication between LISP Data and Control Plane is achieved via a dedicated socket (i.e. \emph{LispMappingSocket}) that inherits from ns-3 \emph{Socket} class. The Data Plane implementation is in "kernel space" (i.e. ns-3's \emph{TCP/IP stack}) and Control Plane is implemented in "user space" (i.e. ns-3 \emph{Application}). Such a design is inspired by that of OpenLISP~\cite{saucez2009openlisp}.  

The UML diagram of proposed LISP and LISP mobility implementation is illustrated Fig.~\ref{LISP_UML}. The white blocks refer to the classes that we added into ns-3, while darker blocks are classes already in ns-3. It should be noted that our implementation currently only supports IPv4 at time of this writing. The IPv6 support (i.e. the implementation related to IPv6 such as \emph{LispOverIpv6Impl}) is still in process. In addition, the authentication procedure involved in LISP is not considered in our implementation.% \yue{This figure should be revised. For example, LispHeader should be renamed as LispDataPlaneHeader. MapTable should contains a list of MapEntry.}
%-< FIGURE >--------------------------------------------------------------------
\begin{figure*}[!t]
	\centering
	\includegraphics[width=\textwidth]{Pics/LISP_NS3_UML}
	\caption{UML diagram of LISP and LISP mobility implementation. The solid arrow refers to a composition relation, while the blank one refers to a inheritance relation.}
	\label{LISP_UML}
\end{figure*}
%-< END FIGURE >--------------------------------------------------------------------
%-< SUB SECTION >--------------------------------------------------------------------
\subsection{Implementation of LISP Data Plane}
\label{subsec:modifyInternet}
%\begin{itemize}
%    \item Modification of Receive method
%    \item Modification of Delivery method
%    \item Implementation of LISP encapsulation and decapsulation
%\end{itemize}
The implementation of LISP Data plane mainly consists of \emph{LispOverIp} and \emph{MapTable} classes and their subclasses, along side with some auxiliary classes (e.g. \emph{LispHeader}). In addition, to support LISP functionalites, \emph{Ipv4L3Protcol}'s packet transmission, reception, forward and delivery procedures are accordingly adapted.
\subsubsection{LISP Database and cache}
\label{subsec:database-impl}
Each LISP-speaking node should maintain one LISP database and LISP cache for LISP encapsulation and decapsulation operations. In our implementation, both LISP database and cache are modellized by the same class~\emph{MapTable} that stores and manages EID-RLOC mapping information. This class is in charge of CRUD (Create, Retrieve, Update, Delete) operations for mappings. Each mapping entry in LISP database and cache is an instance of \emph{MapEntry}. For the sake of flexibility, the class \emph{MapTable} is an abstract base class. The CRUD methods are implemented in its subclass \emph{BasicMapTable}. The mapping search operation is a straightforward iteration over LISP database or cache. It is possible that for other users to provide their own LISP database and cache implementation, for example, which uses more sophisticated mapping entry look up algorithms, by extending \emph{MapTable} class.

In addition, \emph{MapTable} has a callback which allows to send the buffered packet (either LISP data plane or control plane) due to LISP cache miss event, upon insertion of the required EID-RLOC mapping information into LISP cache.

\subsubsection{Implementation of LISP encapsulation and decapsulation}
To integrate LISP and LISP mobility into conventional Internet protocol stack, one key technical difficulty is that \emph{Ipv4L3Protcol} should be able to determine when passing a packet being processed to LISP-related procedure and how to retrieve the associated mapping information. To this end, a new class called \emph{LispOverIp} and its extended classes (refer to Fig.~\ref{LISP_UML}) are added to ns-3 \emph{internet} module. This class is in charge of checking whether it is necessary to do LISP-related operations (\emph{NeedEncapsulation()}, \emph{NeedDecapsulation()}), and encapsulating conventional IP packets (i.e., \emph{LispOutput()}) as well as decapsulating LISP packets(\emph{LispInput()}). It contains a smart pointer pointing to the LISP database and LISP cache (e.g.~\emph{MapTable}) on which executes mapping search.
\begin{figure*}[!t]
	\centering
	\includegraphics[width=\textwidth]{Pics/ns3_lisp_data_plane.eps}
	\caption{Illustration of LISP encapsulation and decapsulation}
	\label{fig:ns3-lisp-data-plane}
\end{figure*}

We take a double encapsulation example to illustrate how LISP encapsulation and decapsulation is implemented. We assume that the required mapping entries during LISP Data plane operations are already in LISP-MN cache. A LISP-speaking node behind a xTR router need to communicate with CN before another xTR router. Thus, a packet should be encapsulated within the considered node and forwarded to its xTR. Subsequently, the packet is further encapsulated and forwarded. At the xTR which serves the CN, the received packet is decapsulated twice and forwarded. Thus, the example involves packet transmission, forwarding, reception, which is illustrated by Fig.~\ref{fig:ns3-lisp-data-plane}. 

With the MN node, when upper layer calls the \emph{send()} method of \emph{Ipv4L3Protcol}, a packet comes down to IP layer. The \emph{send()} method is adapted so that    
it first verifies whether the \emph{LispOverIp} object is present. If yes, some checks are then conducted to determine that this packet should be processed by \emph{LispOutput()} (to encapsulate the packets) or by conventional packet transmission routine. For example, if both source and destination IP address of this packet belong to the same network, the LISP-related process (e.g., encapsulation) is skipped and this packet is processed as in a non-LISP network. Otherwise, EID-RLOC mapping information is searched from LISP cache and LISP database on LISP-MN node. 

After encapsulation and forwarding, the considered packet is forwarded to xTR1. This procedure is illustrated in Fig.~\ref{fig:ns3-lisp-data-plane}. Low layer invokes the \emph{Receive} method of \emph{Ipv4L3Protocol} to pass this packet to IP layer. Since this packet is destinated to a remote CN instead of itself, this packet is processed by patched \emph{IpForward} method. % , \emph{IpForward} method of \emph{Ipv4L3Protocol} is called. 
With this method, LISP encapsulation is verified. LispOverIp looks for source RLOC (RLOC of xTR1) and destination RLOC (RLOC of xTR2) for the outter IP header building. Once this step is done, Ipv4L3Protocol's send method transmits these encapsulated packet to MAC layer for transmission.

When this packet arrives at xTR2 which servers CN, xTR2 finds that the destination of this packet is the node itself, the packet is processed by \emph{LocalDelivery} method in \emph{Ipv4L3Protocol}. Before passing to transport layer, \emph{LocalDelivery} checks if the packet should be decapsulated. If yes, it is passed to \emph{LispInput} method, in which the packet is decapsulated and reinjected in the IP stack. That is to say, \emph{Receive} method is called again after decapsulation operation. If the packet still has LISP header, the aforementioned procedure will repeated until it has no need to be decapsulated. Finally, the packet with source address of MN and destination address of CN is forwarded to CN.

%-< SUB SECTION >--------------------------------------------------------------------
\subsection{Implementation of LISP Control Plane}
\label{subsec:control-plane-impl}
%\begin{itemize}
%    \item Implementation of xTR under ns3
%    \item Implementation of MS under ns3
%    \item Socket communication between control plan and data plan
%\end{itemize}
The implementation of LISP Control Plane at least should provide ITR/ETR, MR and MS. In practice, ETR and ITR functionalities are usually placed on a same router called xTR. In our implementation, they are included into class \emph{LispEtrItrApplication}.
The functionalities of MS and MR are respectively implemented by class \emph{MapServer} and \emph{MapResolver}. The LISP Control plane messages (Map-Register, Map-Request, etc.) are represented by the derived classes of \emph{LispControlMsg}. In addition, to communicate with LISP Data Plane, a socket class \emph{LispMappingSocket} is proposed.

\subsubsection{Implementation of xTR functionalities}
A ns-3 node that runs \emph{LispEtrItrApplication} is a LISP-compatible router. It should be able to communicate with \emph{LispOverIp} on the same node (e.g. inform cache missing event) and other LISP-compatible routers (e.g. Map-Request/Map-Reply). 
\begin{figure*}[!t]
	\centering
	\includegraphics[width=\textwidth]{Pics/xTR_state_transition.eps}
	\caption{State transition diagram of xTR application}
	\label{fig:xTR-state-transition}
\end{figure*}
The state transition diagram is illustrated in Fig.~\ref{fig:xTR-state-transition}. When destination RLOC is not found in the cache of xTR for a processed packet, the cache miss event occurs and LISP data plane (e.g. \emph{LispOverIp}) notifies \emph{LispEtrItrApplication} on the same LISP-MN node of this event via a \emph{LispMappingSocket} socket. Once reception of cache missing event from LISP Data Plane (i.e. \emph{LispOverIp} object), \emph{LispEtrItrApplication} initiates a Map-Request message to LISP mapping system. Once reception of Map-Reply, the received EID-RLOC mapping is inserted into LISP cache. 
It should be noted that as an implementation choice, before the reception of Map-Reply message, all transmitted packets with the required RLOC as desination are dropped. One can also design a buffer to queue these packets and resend them once the required mapping information is received via Map-Reply.

In case of reception of Map-Request, \emph{LispEtrItrApplication} executes a database look up on \emph{MapTable} and generates the corresponding Map-Reply containing EID-RLOC mapping.

When xTR application starts or LISP database on a node has information update (e.g. during a handover scenario), xTR application sends a Map-Register message and waits for a Map-Notify message. In case of LISP database update, xTR sends a SMR message to all xTR whose RLOC is present in its cache. %, upon the reception of Map-Notify message. 
According to RFC 6830~\cite{rfc6830}, the xTR receiving the SMR has two possibilities of reactions about sending SMR-invoked Map-Request:  towards a mapping system or the xTR initiating this SMR. Both cases are implemented in our work and this can be configured by an attribute of \emph{LispEtrItrApplication}. It should be noted that in double-encapsulation, if invoked-SMR is directly sent to LISP-MN node whose local RLOC address is unknown for xTR, the first invoked-SMR cannot be sent due to cache miss. We implement a callback function within \emph{BasicMapTable} which allows to send immediately the buffered invoked-SMR upon insertion of required EID-RLOC mapping into cache. Note that this mechanism is designed only for LISP Control Plane messages. LISP Data Plane is dropped in case of cache miss.

To support LISP-MN feature, \emph{LispEtrItrApplication} also communicates with DHCP client application. For example, once a LISP-MN obtains an IP address from DHCP server, \emph{LispEtrItrApplication} receives the corresponding EID-RLOC mapping and sends a Map-Register message to the Map Server.

\subsubsection{Implementation of Map server and Map resolver}
A node that runs a \emph{MapServer} application is the MS in a LISP-supported network. This class maintains a LISP database to store the EID-RLOC mapping information, learned from Map-Register message at the initialization stage. Each time MS receives a Map-Request message, it looks up the required EID and forward this request to the corresponding xTR. In current implementation, the role of MR is to receive the Map-Request message from xTR and forward it to the MS.

\subsection{Modification of DHCP client to support LISP-MN}
\label{subsec:DHCP}
%\begin{itemize}
%    \item LISP-MN, in case of IPv4, need the intervention of DHCP procedure
%    \item The current version of DHCPv4 is not compatible with LISP
%    \item Implementation of LISP-compatible DHCPv4 based on conventional DHCPv4
%\end{itemize}
To support LISP mobility for IPv4, the intervention of DHCP is indispensable. From ns-3.27, DHCP client and server have been implemented in module \emph{internet-apps}. However, the DHCP client of ns-3 is not compatible with LISP. Thus, conventional DHCP client is adapted to support LISP.
\begin{figure*}[!t]
	\centering
	\includegraphics[width=0.9\textwidth]{Pics/DHCP_transition_state.eps}
	\caption{LISP-compatible DHCP client state transition diagram}
	\label{fig:DHCP-state-transition}
\end{figure*}
The state transition diagram of DHCP client is illustrated in Fig.~\ref{fig:DHCP-state-transition}. When a LISP-MN node roams into the area covered by another xTR, the boot procedure of DHCP client is triggered once that the link state is changed. Afterwards, the DHCP client sequentially pass `INIT', `SELECTING', `Requesting' states and enter into `Bound` state after the reception of DHCP ACK message from DHCP server.
In `Bound' state, apart from saving the newly obtained IPv4 address (namely local RLOC) and default gateway, DHCP client should be able to check if the local RLOC is different from the one associated with its EID in its LISP database.
If local RLOC is changed, DHCP client enters into state of `LISP database update'. DHCP client is equipped with a dedicated socket of type \emph{LispMappingSocket}. By this socket, DHCP client notifies the \emph{LispEtrItrApplication} by sending a dedicated message that contains the EID-LRLOC mapping. \emph{LispEtrItrApplication} is in charge of populating the received mapping entry into LISP database and sending a Map-Register message to the Map Server.

To be compatible with DHCP, conventional LISP-related process is also modified. For example, to transmit a DHCP Discovery message (application layer message), its source IP address is set as $0.0.0.0$. The \emph{Send} method of \emph{Ipv4L3Protocol} should be modified so that this message is not processed \emph{LispOverIp}.

%-< SUB SECTION >--------------------------------------------------------------------
\subsection{Integration of TUN net interface card}
\label{subsec:tundevice}
To support mobility, a LISP-speaking node actually can be regarded as a small LISP-Site. The xTR functionalities and DHCP service should be implemented on LISP-MN node. The address of MR and MS should be configured. As a LISP-MN node, it has a static permanent EID and dynamic RLOC assigned by the DHCP server. To differentiate with conventional RLOC of xTR interface, such kind of RLOC is referred to as the local RLOC (LRLOC). Thus, different from a conventional LISP node, at least two net interface cards (NIC) should be installed into LISP-MN node. One is normal NIC such as~\emph{WifiNetDevice}. The DHCP client application runs on this kind of card and thus the LRLOC is allocated to this card. The other is a TUN type card. The TUN net interface card is a virtual card which should actually invoke~\emph{Send} of another real net interface card. The permanent EID is assigned to \emph{VirtualNetDevice} net card. 

To make the packets from application layer always use EID as the source IP address of inner IP header, two static route entries (shown in Tab.~\ref{tab:static-route-table}) are added into static route of LISP-MN node.
\begin{table}[]
	\centering
	\caption{Static route table of LISP-MN node}
	\label{tab:static-route-table}
	\begin{tabular}{ll}
		Destination Prefix & Interface \\
		0.0.0.0/1          & TUN       \\
		128.0.0.1/1        & TUN      
	\end{tabular}
\end{table}

%-< SUB SECTION >--------------------------------------------------------------------

%-< SECTION >--------------------------------------------------------------------
\section{Theoretical analysis}
\label{sec:ns3_analysis}
IP mobility leveraging on LISP can be implemented either on the border router or the end host. To explore the characteristics of each scheme, we propose the following three different scenarios and analyze the overall handover delay and control plane overhead. 
\begin{enumerate}[noitemsep,topsep=0pt]
	\item LISP-MN in the non-LISP-Site (i.e., only the end host supports LISP). 
	\item MN in the LISP-Site (i.e., only the border router supports LISP). 
	\item LISP-MN in the LISP-Site (i.e., both the border router and the end host support LISP). 
\end{enumerate}	
%-< FIGURE >--------------------------------------------------------------------
\begin{figure}[!th]
	\centering
	\includegraphics[width=0.8\textwidth]{Pics/LISP_mobility_archi}
	\caption{General scenario for LISP mobility architecture}
	\label{sim_archi}
\end{figure}
%-< END FIGURE >--------------------------------------------------------------------

% -<Descriptions with parameters>--------------------------------------------------------------------
% All the scenarios are based on a same simulation architecture shown in Fig.~\ref{sim_archi}, but with some slight differences, which will be respectively specified in the following parts from Sec.~\ref{sec:ns3_analysis_lispmn} to Sec.~\ref{sec:ns3_analysis_lispmn_xTR}. In our designed architecture, an MN is initially in the subnet of $Router_1$. An \emph{echo} application on MN sends packets to a remote stationary node CN in the LISP-Site of $xTR_3$. The distance between xTR\_1 and xTR\_2 is $170 m$. The connection between MN and xTR\_1 can be either Wi-Fi or wired link. If they use Wi-Fi, MN will move into the subnet of $Router_2$ at speed of $7.07 m/s$ after several seconds when the simulation begins. The start time of movement is a random value in the range of $[x, x] s$. At a certain moment during the moving, the Wi-Fi link between MN and $Router_1$ is down, which triggers the handover procedure. Afterwards, MN connects to $Router_2$ and reestablishes the communication with CN node. If they use wired link, the connection of MN with $Router_1$ will be down and the one with $Router_2$ will be up at the same time. This action also triggers the handover procedure. Every link between two network entities in this simulation architecture is set to $20 ms$.

The network topology for all the scenarios is shown Fig.~\ref{sim_archi}. An MN is initially in the subnet of $Router_1$. It exchanges packets to a remote stationary node CN situated in the LISP-Site of $xTR_3$. The roles of $Router_1$ and $Router_2$ are slightly different in different scenarios. This will be respectively specified in the following parts (Sec.~\ref{sec:ns3_analysis_lispmn} to Sec.~\ref{sec:ns3_analysis_lispmn_xTR}). To obtain the estimation of LISP mobility handover, we do not consider the delay due to wireless link switch and use an intermediate router to connect all three routers and the mapping system. The connection between MN and $Router_1$ can be either Wi-Fi or wired link. If Wi-Fi link is used, MN will move into the subnet of $Router_2$ at a constant speed. At a certain moment, the Wi-Fi link between MN and $Router_1$ is down, which triggers the handover procedure. Afterwards, MN connects to $Router_2$ and reestablishes the communication with CN node. If they use wired link, the handover procedure can be simulated as follows. The MN have two interfaces respectively connected to $Router_1$ and $Router_2$. At a certain time, the connection to $Router_1$ set to be down and the one with $Router_2$ is set to be up. At the same time, the DHCP client on the interface connected to $Router_2$ is run and this triggers the handover procedure.

In this chapter, the overall handover delay $D_{overall}$ is defined as the time interval between the last packet received by MN from CN via $Router_1$ and the first packet received by MN from CN via $Router_2$ after the link reestablishment. The overall handover overhead $C_{overall}$ is defined as the number of LISP control plane messages exchanged during handover procedure.
According to the three following scenarios, the handover delay and overhead consist of different parts. All the necessary delay and LISP overhead of control plane during the mobility are listed in Tab.~\ref{Symbols_numerical_analysis}.
%-< TABLE >-----------------------------------------------------------------
\begin{table}[!tb]
	\centering
	\caption{Symbols for numerical analysis}
	\label{Symbols_numerical_analysis}{
		% \resizebox{0.9\textwidth}{!}{%
		\begin{tabular}{@{}|c|c|@{}}
			\hline\hline
			Symbols & Explanations   \\ \hline
			$D_{overall}$ & Overall handover delay	\\  \hline    
			$D_{DHCP}$ &  DHCP address configuration delay \\  \hline    
			$D_{Register}$ &  Delay of sending Map-Register      	\\  \hline
			$D_{Notify}$ &  Delay of receiving Map-Notify      	\\  \hline           
			$D_{Request}$ &  Delay of sending Map-Request to MDS      	\\  \hline   
			$D_{Reply}$ &  Delay of receiving Map-Reply      	\\  \hline      
			$D_{Resolve}$ &  Delay of resolving mapping information in MDS      	\\  \hline               
			$D_{SMR}$ &  Delay of sending SMR       	\\  \hline 
			$D_{Request_{SMR}}$ &  Delay of sending a SMR-invoked Map-Request \\  \hline 
			$D_{Link}$ &  Link delay between two network entities \\  \hline 
			$T_{A-B}$ &  Delay of packet transmission between A and B     	\\  \hline
			$T_{timeout_SMR}$ &  Timeout of SMR \\  \hline  \hline    
		\end{tabular}
	}
\end{table}
%-< END TABLE >-----------------------------------------------------------------



%-< SUBSECTION >--------------------------------------------------------------------
\subsection{LISP-MN in non-LISP-Site}
\label{sec:ns3_analysis_lispmn}
The first scenario is the LISP-MN in non-LISP-Site, where the border routers are the conventional routers and LISP is only implemented on the mobile end host MN. In our simulation, the LISP-MN with permanent EID is initially placed in the subnet of $Router_1$, with the IP address distributed by $Router_1$ as its RLOC. The remote CN is a conventional stationary end host, residing in a LISP-Site of $xTR_3$. % The LISP-MN communicates with CN by encapsulating the packets on itself and decapsulating the packets on $xTR_3$. If we use Wi-Fi, the LISP-MN moves into subnet of $Router_2$ after the simulation begins. At a certain moment during the moving, the Wi-Fi link between LISP-MN and $Router_1$ is down, whereas LISP-MN detects $Router_2$, which triggers the handover procedure. If we use wired link, after a certain time that the simulation begins, we turn down the wired link between LISP-MN and $Router_1$, while set the link between LISP-MN and $Router_2$ up at the same time. 
LISP-MN first has a DHCP procedure when MN moves to $Router_2$, so that the later allocates a new IP address as RLOC. Then LISP-MN needs register its new mapping information to the mapping system, and also send a $SMR$ to its communicating nodes in its cache (there is only CN in our scenario). $xTR_3$ sends an SMR-invoked Map-Request to the mapping system, so to obtain the new mapping information of LISP-MN. Afterwards, LISP-MN reestablishes the communication with CN node via $Router_2$. The detailed traffic schema related to the handover procedure is illustrated in Fig.~\ref{sim_schema_LISPMN}.  % The total simulation time is set to $45s$ and the DHCP procedure delay is set to $1s$. We conduct many times of simulations with the various beacon interval of Wi-Fi channel in the range of $0.05s$ to $2s$.
%-< FIGURE >--------------------------------------------------------------------
\begin{figure}[!th]
	\centering
	\includegraphics[width=0.8\textwidth]{Pics/Mobility_LISPMN_schema_SMR_simplify}
	\caption{Schema for LISP-MN mobility (SMR-invoked Map-Request is sent to the mapping system)}
	\label{sim_schema_LISPMN}
\end{figure}
%-< END FIGURE >--------------------------------------------------------------------

The overall handover delay $D_{overall}$ in this scenario is composed by two parts: the DHCP related delay and LISP related delay. The delay of DHCP procedures consist of LISP-MN sending DHCP Discovery message to $Router_2$, receiving DHCP Offer message, sending DHCP Request message, and receiving DHCP ACK message. The delay of all the LISP procedures are presented in Fig.~\ref{sim_schema_LISPMN}. Thus, the overall handover delay is:
\begin{eqnarray}
D_{overall} &=& D_{DHCP} + D_{Register} + D_{Notify} + D_{SMR} + D_{Request_{SMR}} + D_{Reply} \nonumber \\
% &=& D_{DHCP} + T_{MN-MDS} + T_{MDS-MN} + T_{MN-xTR_3} + (T_{xTR_3-MDS} + D_{Resolve} + T_{MDS-MN}) + T_{MN-xTR_3} \nonumber \\
&=& D_{DHCP} + 3T_{MN-MDS} + 2T_{MN-xTR_3} + T_{xTR_3-MDS} + D_{Resolve} \nonumber \\
&=& D_{DHCP} + 3* (3*D_{Link}) + 2*(3*D_{Link}) + 2*D_{Link} + D_{Resolve}\nonumber \\
% &=& D_{DHCP} + 3* (3*2ms) + 2*(3*2ms) + 2*2ms + D_{Resolve} \nonumber \\
&=& D_{DHCP} + 17D_{Link} + D_{Resolve}
% &=& D_{DHCP} + 234 ms \nonumber
\end{eqnarray}
where $D_{DHCP}$ represents the time elapsed between the DHCP Discover sent by the LISP-MN, and the DHCP ACK message sent by the $Router_2$. % Every link between two network entities in this simulation architecture is set to $2 ms$. According to the experimental results in~\cite{coras2014performance}, we set the resolving time in the mapping system as $200 ms$. % (Min value of handover delay = 1.073031 s, where packet sending interval = 0.01 s)

The handover overhead is 6 messages of LISP control plane. It includes 2 signalings of registration when LISP-MN connects to $Router_2$ (Map-Register and Map-Notify), and 4 signalings related to SMR procedure: 1 SMR from $xTR_3$ to $Router_2$, 1 SMR-invoked Map-Request from $xTR_3$ to the mapping system, 1 Map-Request forwarded by mapping system to $Router_2$, and 1 Map-Reply from $Router_2$ to $xTR_3$.
%\begin{eqnarray}
%C_{overall} &=& C_{Register} + C_{Notify} + C_{SMR} + C_{Request_{SMR}} + C_{Reply} \nonumber \\
%&=& C_{Register} + C_{Notify} + C_{SMR} + 2C_{Request} + C_{Reply} \nonumber \\
%&=& 6 C
%\end{eqnarray}

There are two options when $xTR_3$ receives $SMR$. It can send the SMR-invoked Map-Request to the mapping system as we described before, or it can directly send the SMR-invoked Map-Request to the source locator address of $SMR$~\cite{rfc6830}. In this scenario, the source of $SMR$ is LISP-MN. Thus, the numerical analysis of overall handover delay $D_{overall}$ is as follows:
\begin{eqnarray}
D_{overall} &=& D_{DHCP} + D_{Register} + D_{Notify} + D_{SMR} + D_{Request_{SMR}} + D_{Reply} \nonumber \\
% &=& D_{DHCP} + T_{MN-MDS} + T_{MDS-MN} + T_{MN-xTR_3} + T_{xTR_3-MN} + T_{MN-xTR_3} \nonumber \\
&=& D_{DHCP} + 2T_{MN-MDS} + 3T_{MN-xTR_3}  \nonumber \\
&=& D_{DHCP} + 2* (3*D_{Link}) + 3*(3*D_{Link}) \nonumber \\
% &=& D_{DHCP} + 2* (3*2ms) + 3*(3*2ms) \nonumber \\
&=& D_{DHCP} + 15D_{Link}
% &=& D_{DHCP} + 30 ms \nonumber
\end{eqnarray}
Compared with solution of sending SMR-invoked Map-Request to the mapping system, the overall handover delay of sending the SMR-invoked Map-Request back to the source of $SMR$ is smaller, since there is no resolving delay in the mapping system. % This solution is more interesting for the case that the distance to mapping system is much longer than that to the source of $SMR$.

In this scenario, the handover overhead associated to LISP control plane is 5 messages. Since the SMR-invoked Map-Request is directly sent from $xTR_3$ to $Router_2$ instead of passing the mapping system, it has 1 signaling less than the one sent to the mapping system.
%\begin{eqnarray}
%C_{overall} &=& C_{Register} + C_{Notify} + C_{SMR} + C_{Request_{SMR}} + C_{Reply} \nonumber \\
%&=& C_{Register} + C_{Notify} + C_{SMR} + C_{Request} + C_{Reply} \nonumber \\
%&=& 5 C
%\end{eqnarray}

The advantages of this scenario, i.e., LISP-MN in non-LISP-Site, are: 
\begin{inparaenum}[1)]
	\item it is able to achieve seamless handover through different subnets;
	\item the numerical analysis indicates that the overall handover delay is small;
	\item so to the overall overhead. The mobility does not cause lots of traffic in LISP control plane.
\end{inparaenum}
However, since the routers are still the normal routers in this scenario, it can not help to reduce the BGP routing table size, which is the initial purpose to motivate LISP. Moreover, each LISP-MN needs a permanent IP address as its EID, which increases the burden of IPv4 address distribution. Each permanent EID and its RLOC needs register to the mapping system, which also increases the size of LISP mapping table.

%-< SUBSECTION >--------------------------------------------------------------------
\subsection{MN in LISP-Site}
\label{sec:ns3_analysis_xTR}
The second scenario is the MN in LISP-Site, where the mobile node MN is conventional and LISP are only implemented on the border routers. In our simulation, the MN is initially placed in the subnet of $xTR_1$, with the assigned IP address as its EID. The remote CN is same to the first scenario. The MN communicates with CN by encapsulating the packets on $xTR_1$ and decapsulating the packets on $xTR_3$, and the MN moves into the coverage of $xTR_2$ after the simulation begins. Since the communication should not be interrupted during the mobility, this scenario limits the movement of MN being only within the same subnet, i.e., one of the EID-prefixes of $xTR_1$ is same to one of $xTR_2$'s. % At a certain moment during the moving, the Wi-Fi link between MN and $xTR_1$ is down, whereas MN detects $xTR_2$, which triggers the switching connection procedure. If we use wired link, after a certain time that the simulation begins, the wired link between MN and $xTR_1$ is down, meanwhile the link between MN and $xTR_2$ is up. 
Similar to the first scenario, the DHCP procedure is necessary so to trigger the registration of new mapping information, but MN still keeps the former IP address as its EID, instead of $xTR_2$ distributing a new one to it. Then $xTR_2$ registers its new mapping information to the mapping system. As the mapping system finds out that the EID of MN has been registered and associated by $xTR_1$, it sends a Map-Notify to both xTRs. The reason for sending to $xTR_2$ is the acknowledgment of the reception of its Map-Register. Whereas the purpose to $xTR_1$ is to tell it that the MN is now mapping with $xTR_2$ and inform the remote CN to update its mapping information. Since MN used $xTR_1$ to communicate with CN in the past time, only $xTR_1$ stored in its cache that to whom MN was exchanging the packets instead of $xTR_2$. Thus, $xTR_1$ sends a $SMR$ to $xTR_3$, and $xTR_3$ sends an SMR-invoked Map-Request to the mapping system, so to obtain the new mapping information of MN. Afterwards, MN reestablishes the communication with CN node via $xTR_2$. The detailed traffic schema related to the handover procedure is shown in Fig.~\ref{sim_schema_xTR}.
%-< FIGURE >--------------------------------------------------------------------
\begin{figure}[!th]
	\centering
	\includegraphics[width=0.8\textwidth]{Pics/Mobility_xTR_schema_SMR_simplify}
	\caption{Schema for LISP-MN mobility (SMR-invoked Map-Request is sent to the mapping system)}
	\label{sim_schema_xTR}
\end{figure}
%-< END FIGURE >--------------------------------------------------------------------

The overall handover delay $D_{overall}$ in this scenario is almost same to the first one. The numerical analysis is as follows:
\begin{eqnarray}
D_{overall} &=& D_{DHCP} + D_{Register} + D_{Notify} + D_{SMR} + D_{Request_{SMR}} + D_{Reply} \nonumber \\
% &=& D_{DHCP} + T_{xTR_2-MDS} + T_{MDS-xTR_1} + T_{xTR_1-xTR_3} + T_{xTR_3-MDS} + D_{Resolve} + T_{MDS-xTR_2} + T_{xTR_2-xTR_3} \nonumber \\
&=& D_{DHCP} + 2T_{xTR_2-MDS} + T_{MDS-xTR_1} + T_{xTR_1-xTR_3} + T_{xTR_3-MDS} + \nonumber \\
& & D_{Resolve} + T_{xTR_2-xTR_3} \nonumber \\
&=& D_{DHCP} +2* (2*D_{Link}) + 2*D_{Link} + 2*D_{Link} + 2*D_{Link} + D_{Resolve} + 2*D_{Link} \nonumber \\
% &=& D_{DHCP} +2* (2*2ms) + 2*2ms + 2*2ms + 2*2ms + D_{Resolve} + 2*2ms \nonumber \\
&=& D_{DHCP} + 12D_{Link} + D_{Resolve} 
% &=& D_{DHCP} + 224 ms \nonumber
\end{eqnarray}
% $CheckAlive$ is the delay that xTR\_1 checks if MN still connects to it. For example, xTR\_1 can simply \emph{ping} MN. If MN still connects to it, it will reply to mapping system that itself is still RLOC of MN. Otherwise, if \emph{ping} meets timeout, xTR\_1 will tell the mapping system that MN has left, and sends SMR to the CNs in its cache. The later situation has higher delay, because xTR\_1 needs to wait until timeout of \emph{ping}. % (Min value of simulation = 1.067679 s, where includes 1 s of DHCP delay)

The handover overhead in this scenario is 7. Besides 4 messages used for SMR procedure, it needs 3 signalings to complete the registration. There are 1 Map-Register from MN to the mapping system and 2 messages of Map-Notify: 1 to the $xTR_2$ and 1 to the $xTR_1$.
%\begin{eqnarray}
%C_{overall} &=& C_{Register} + 2C_{Notify} + C_{SMR} + C_{Request_{SMR}} + C_{Reply} \nonumber \\
%&=& C_{Register} + 2C_{Notify} + C_{SMR} + 2C_{Request} + C_{Reply} \nonumber \\
%&=& 7 C
%\end{eqnarray}

Same to the first scenario having two options, when $xTR_3$ receives the $SMR$ from $xTR_1$, it can also directly send SMR-invoked Map-Request back to $xTR_1$, which implies that the $xTR_1$ puts the new mappings into its database. The overall handover delay $D_{overall}$ is as follows:
\begin{eqnarray}
D_{overall} &=& D_{DHCP} + D_{Register} + D_{Notify} + D_{SMR} + D_{Request_{SMR}} + D_{Reply} \nonumber \\
% &=& D_{DHCP} + T_{xTR_2-MDS} + T_{MDS-xTR_1} + T_{xTR_1-xTR_3} + T_{xTR_3-xTR_2} + T_{xTR_2-xTR_3} \nonumber \\
&=& D_{DHCP} + T_{xTR_2-MDS} + T_{MDS-xTR_1} + T_{xTR_1-xTR_3} + 2T_{xTR_2-xTR_3} \nonumber \\
&=& D_{DHCP} +2*D_{Link} + 2*D_{Link} + 2*D_{Link} + 2*(2*D_{Link}) \nonumber \\
% &=& D_{DHCP} +2*2ms + 2*2ms + 2*2ms + 2*(2*2ms) \nonumber \\
&=& D_{DHCP} + 10D_{Link} 
% &=& D_{DHCP} + 20 ms \nonumber
\end{eqnarray}
Since the SMR-invoked Map-Request is not sent to the mapping system, there is no resolving delay. %, and the overall handover delay is much smaller than the former solution. 
However, in this scenario, as $xTR_1$ has not been in charged of MN, how long it stores the CNs for MN in its cache is an important point to discuss. If the expired time is set too long, it wastes the source of $xTR_1$ and is not necessary. Whereas if the time is too short, there is the risk that remote CNs like $xTR_3$ in our scenario, do not have enough time to request the new mapping information.

Similarly to the first scenario that directly responding to the source locator of SMR has 1 signaling less than the one requesting to the mapping system first. Thus, the overall handover overhead in this case is 6.
%\begin{eqnarray}
%C_{overall} &=& C_{Register} + 2C_{Notify} + C_{SMR} + C_{Request_{SMR}} + C_{Reply} \nonumber \\
%&=& C_{Register} + 2C_{Notify} + C_{SMR} + C_{Request} + C_{Reply} \nonumber \\
%&=& 6 C
%\end{eqnarray}

Since the routers support LISP, i.e., are the xTRs in this scenario, it can help to reduce the BGP routing table size, which is the initial motivation of proposing LISP. Besides, the analysis hints that the overall handover delay of this scenario is the shortest. However, it can only provide the mobility within a same subnet without any interrupt, but it is not able to offer the seamless handover through different subnets. Thus, this scenario is more suitable to be applied for the mobility of virtual machines in the Data Center.

%-< SUBSECTION >--------------------------------------------------------------------
\subsection{LISP-MN in LISP-Site}
\label{sec:ns3_analysis_lispmn_xTR}
The third scenario is the LISP-MN in LISP-Site, where both the border routers and the mobile node MN are implemented LISP. In our simulation, the LISP-MN with permanent EID is initially placed in the subnet of $xTR_1$, with the IP address allocated by $xTR_1$ as its LRLOC. The remote CN is still same to the first two scenario, which is a conventional stationary end host, residing in a LISP-Site of $xTR_3$. The LISP-MN communicates with CN by double encapsulation. The first encapsulation is on itself and the second time is on the $xTR_1$. When the LISP packets arrive at $xTR_3$, it needs decapsulate them twice. % If we use Wi-Fi, the LISP-MN moves into subnet of $xTR_2$ after the simulation begins. At a certain moment during the moving, the Wi-Fi link between LISP-MN and $xTR_1$ is down, whereas LISP-MN detects $xTR_2$, which triggers the handover procedure. If we use wired link, after a certain time that the simulation begins, we turn down the wired link between LISP-MN and $xTR_1$, while set the link between LISP-MN and $xTR_2$ up at the same time. 
LISP-MN first has a DHCP procedure with $Router_2$, so that the later assigns it a new IP address as its LRLOC. Then LISP-MN needs register its new mapping information to the mapping system, and also send a $SMR$ to all the CNs in its cache (there is only $xTR_3$ in our scenario). Once $xTR_3$ receives a $SMR$, it sends an SMR-invoked Map-Request to the mapping system, so to obtain the new mapping information of LISP-MN. Actually this mapping information that $xTR_3$ obtains is the $<EID_{LISPMN}, LRLOC>$ for LISP-MN. It is not able to send the packets to LISP-MN at the moment, since it does not know how to route the packets to LISP-MN, i.e., it lacks the mapping information for LRLOC. Only until $xTR_3$ receives the packets from CN to LISP-MN, which triggers the Map-Request procedure to the mapping system, can $xTR_3$ know the mapping information of LRLOC $<LRLOC, RLOC_{xTR_2}>$. Now $xTR_3$ gets the double mapping information for LISP-MN. Afterwards, LISP-MN reestablishes the communication with CN node by passing $xTR_2$. The detailed traffic schema related to the handover procedure is illustrated in Fig.~\ref{Mobility_double_encap_schema_SMR_askMDS_simplify}.
%-< FIGURE >--------------------------------------------------------------------
\begin{figure}[!th]
	\centering
	\includegraphics[width=0.8\textwidth]{Pics/Mobility_double_encap_schema_SMR_askMDS_simplify}
	\caption{Schema for LISP-MN in LISP-Site mobility (SMR-invoked Map-Request is sent to the mapping system)}
	\label{Mobility_double_encap_schema_SMR_askMDS_simplify}
\end{figure}
%-< END FIGURE >--------------------------------------------------------------------

Since this scenario is double encapsulation that $xTR_3$ needs to know both inner and outer mapping information of LISP-MN for sending the packets. The overall handover delay $D_{overall}$ in this scenario is larger than the first two scenarios. The numerical analysis is as follows:
\begin{eqnarray}
D_{overall} &=& D_{DHCP} + D_{Register} + D_{Notify} + D_{SMR} + D_{Request_{SMR}} + D_{Reply} +  \nonumber \\
& & D_{Request}+ D_{Reply} \nonumber \\
% &=& D_{DHCP} + 2T_{MN-MDS} + T_{MN-xTR_3} + T_{xTR_3-MDS} + D_{Resolve} + T_{MDS-MN} + T_{MN-xTR_3} + T_{xTR_3-MDS} + D_{Resolve} + T_{MDS-xTR_2} + T_{xTR_2-xTR_3}   \nonumber \\
&=& D_{DHCP} + 3T_{MN-MDS} + 2T_{MN-xTR_3} + 2T_{xTR_3-MDS} + 2D_{Resolve} +   \nonumber \\
& & T_{MDS-xTR_2} + T_{xTR_2-xTR_3}   \nonumber \\
&=& D_{DHCP} + 3* (3*D_{Link}) + 2*(3*D_{Link}) + 2*(2*D_{Link}) + 2D_{Resolve} +  \nonumber \\
& & 2*D_{Link} + 2*D_{Link} \nonumber \\
% &=& D_{DHCP} + 3* (3*2ms) + 2*(3*2ms) + 2*(2*2ms) + 2D_{Resolve} +  \nonumber \\
% & & 2*2ms + 2*2ms \nonumber \\
&=& D_{DHCP} + 23D_{Link} + D_{Resolve} 
% &=& D_{DHCP} + 446 ms \nonumber
\end{eqnarray}

The double encapsulation causes not only longer handover delay but also more handover overhead related to LISP control plane. Two messages are needed for the registration, three signalings are used to obtain the $LRLOC$ of $EID$. Besides, two more Map-Requests (one from $xTR_3$ to the mapping system, one from the mapping system to $xTR_2$) and one more Map-Reply are required to get the $RLOC$ of $LRLOC$. Thus, the handover overhead is 9, which has 3 messages more than the first scenario.
%\begin{eqnarray}
%C_{overall} &=& C_{Register} + C_{Notify} + C_{SMR} + C_{Request_{SMR}} + C_{Reply} + C_{Request} + C_{Reply} \nonumber \\
%&=& C_{Register} + C_{Notify} + C_{SMR} + 2C_{Request} + C_{Reply} + 2C_{Request} + C_{Reply} \nonumber \\
%&=& 9 C
%\end{eqnarray}

Differently from the first two scenarios, when $xTR_3$ directly sends the SMR-invoked Map-Request back to the source of $SMR$ has smaller overall handover delay, this solution for the third scenario has bigger delay instead. It is caused by the double encapsulation in this scenario while the first two scenarios have only single encapsulation. When $xTR_3$ receives the $SMR$ from LISP-MN, it wants to sends SMR-Invoked Map-Request to the LISP-MN for the mapping information of $<EID_{LISP-MN}, LRLOC_{LISP-MN}>$, but it does not know how to reach to LISP-MN, i.e., it lacks the mapping information of $<LRLOC_{LISP-MN}, RLOC_{xTR_2}>$. Thus, it discards the $SMR$ and sends the $Map-Request$ to the mapping information first. Then, the mapping information of $<LRLOC_{LISP-MN}, RLOC_{xTR_2}>$ is stored in its cache, and waits for the next $SMR$ so to send the SMR-invoked Map-Request to the LISP-MN. The traffic schema is shown in Fig.~\ref{Mobility_double_encap_schema_SMR_askxTR_simplify}.
%-< FIGURE >--------------------------------------------------------------------
\begin{figure}[!th]
	\centering
	\includegraphics[width=0.8\textwidth]{Pics/Mobility_double_encap_schema_SMR_askxTR_simplify}
	\caption{Schema for LISP-MN in LISP-Site mobility (SMR-invoked Map-Request is sent to the source of SMR)}
	\label{Mobility_double_encap_schema_SMR_askxTR_simplify}
\end{figure}
%-< END FIGURE >--------------------------------------------------------------------

The overall handover delay $D_{overall}$ by sending the SMR-invoked Map-Request to the source of $SMR$ in this scenario is as follows, where $T_{timeout\_SMR}$ is set to $1 s$ in the simulation:
\begin{eqnarray}
D_{overall} &=& D_{DHCP} + D_{Register} + D_{Notify} + D_{SMR} + T_{timeout_SMR} + D_{SMR} +  \nonumber \\
& & D_{Request_{SMR}} + D_{Reply} \nonumber \\
&=& D_{DHCP} + 2T_{MN-MDS} + 4T_{MN-xTR_3} + T_{timeout_SMR}\nonumber \\
&=& D_{DHCP} + 2* (3*D_{Link}) + 4*(3*D_{Link}) + T_{timeout\_SMR} \nonumber \\
% &=& D_{DHCP} + 2* (3*2ms) + 4*(3*2ms) + 1s \nonumber \\
&=& D_{DHCP} + 18D_{Link} + T_{timeout\_SMR} 
% &=& D_{DHCP} + 1036 ms \nonumber
\end{eqnarray}

Although when the SMR-invoked Map-Request directly sent to the source of SMR has the different traffic schema from the one sent to the mapping system, the overall handover overhead is still 9. The difference between them is only the order of getting mapping information on $xTR_3$, where this case is to obtain the outer mapping first but the last case is to get the inner mapping first.
%\begin{eqnarray}
%C_{overall} &=& C_{Register} + C_{Notify} + C_{SMR} + 2C_{Request} + C_{Reply} + C_{SMR} +  \nonumber \\
%& & C_{Request_{SMR}} + C_{Reply} \nonumber \\
%&=& C_{Register} + C_{Notify} + 2C_{SMR} + 3C_{Request} + 2C_{Reply}  \nonumber \\
%&=& 9 C
%\end{eqnarray}

%%-< FIGURE >--------------------------------------------------------------------
%\begin{figure}[!th]
%	\centering
%	\includegraphics[width=0.8\textwidth]{Pics/Mobility_double_encap_schema_SMR_improving_simplify}
%	\caption{Schema for LISP-MN in LISP-Site mobility}
%	\label{Mobility_double_encap_schema_SMR_improving_simplify}
%\end{figure}
%%-< END FIGURE >--------------------------------------------------------------------
%If we do not consider the security issues, the handover schema can be simplified as shown in Fig.~\ref{Mobility_double_encap_schema_SMR_improving_simplify}.
%\begin{eqnarray}
%	D_{overall} &=& D_{DHCP} + D_{Register} + D_{Notify} + D_{SMR} + D_{Request} + D_{Reply} + D_{Request_{SMR}} + D_{Reply} \nonumber \\
%	&=& D_{DHCP} + 2T_{LISPMN-MDS} + D_{Resolve} + 3T_{LISPMN-xTR_3} \nonumber \\
%	&=& D_{DHCP} + 2* (3*2ms) + 200ms + 3*(3*2ms) \nonumber \\
%	&=& D_{DHCP} + 230 ms
%\end{eqnarray}
%where $D$ is the delay, $BI$ is Beacon Interval, subscriptions $Wi-Fi$, $DHCP$ and $SMR$ respectively refers to Wi-Fi association, DHCP procedure and LISP SMR. (Min value of handover delay = 1.300349, where packet sending interval = 0.02 s) 
%
%After several executions of simulation program, we observe that the overall handover delay changes by the various beacon intervals, in particular the Wi-Fi association delay depends on the different beacon intervals, whereas LISP SMR procedure always cost around $3s$. To get the lower bound of overall handover delay, we can ignore the Wi-Fi association delay when the beacon interval is $500ms$, and the latency due to DHCP procedure is always $1s$. Thus, adopting LISP-MN to conduct the host-based mobility takes at least $4s$. Compared to current most stable solution for host-based IP mobility management MIPv6, which latency including L2 and L3 in a real Wi-Fi testbed is around $3.68s$~\cite{vassiliou2010analysis}, LISP-MN has a higher delay caused by the double encapsulation mechanism introduced by LISP-MN behind LISP-Site. 
%
%During handover, CN can successfully receive packets from LISP-MN right after DHCP procedure being accomplished, but LISP-MN cannot receive the packets from CN until LISP SMR procedure is also finished. Thus, during DHCP procedure, all bi-directional transmitted packets are lost. To improve the performance, \cite{tang2017lisp} proposes a network-level LISP-MN solution, but has not validated their proposals neither in simulation nor in testbed. Our ns-3 implementation can be used to realize them.

Since both the MN and the border routers support LISP, the advantages of this scenario, i.e., LISP-MN in the LISP-Site, are: 
\begin{inparaenum}[1)]
	\item it can help to reduce the BGP routing table size;
	\item it is able to achieve seamless handover through different subnets.
\end{inparaenum}
However, same to the shortcomings for the first scenario, each LISP-MN needs a permanent IP address as its EID, which increases the burden of IPv4 address distribution. Each permanent EID and its RLOC needs register to the mapping system, which also increases the size of LISP mapping table. Besides, the numerical analysis indicates that the overall handover delay is much longer than the other two scenarios due to its double encapsulation.


%%-< SECTION >--------------------------------------------------------------------
%\section{Evaluations}
%\label{sec:ns3_evaluation}
% It runs an \emph{echo} application which sends packets to an \emph{echo} server on a remote stationary node CN situated in the LISP-Site of $xTR_3$.
% Every link between two network entities in this simulation architecture is set to $2 ms$. According to the experimental results in~\cite{coras2014performance}, we set the resolving time in the mapping system as $200 ms$.
%%-< FIGURE >--------------------------------------------------------------------
%\begin{figure}[!th]
%	\centering
%	\includegraphics[width=0.7\textwidth]{Pics/LISP_mobility_LISPMN_PacketInterval}
%	\caption{Impact of packet sending interval on handover delay}
%	\label{LISP_mobility_LISPMN_PacketInterval}
%\end{figure}
%%-< END FIGURE >--------------------------------------------------------------------
%
%%-< FIGURE >--------------------------------------------------------------------
%\begin{figure}[!th]
%	\centering
%	\includegraphics[width=0.7\textwidth]{Pics/LISP_mobility_xTR_PacketInterval}
%	\caption{Impact of packet sending interval on handover delay}
%	\label{LISP_mobility_xTR_PacketInterval}
%\end{figure}
%%-< END FIGURE >--------------------------------------------------------------------
%
%%-< FIGURE >--------------------------------------------------------------------
%\begin{figure}[!th]
%	\centering
%	\includegraphics[width=0.7\textwidth]{Pics/LISP_mobility_double_encap_PacketInterval}
%	\caption{Impact of packet sending interval on handover delay}
%	\label{LISP_mobility_double_encap_PacketInterval}
%\end{figure}
%%-< END FIGURE >--------------------------------------------------------------------

%-< SECTION >--------------------------------------------------------------------

\section{Summary}
\label{sec:ns3_conclusion}
%\begin{itemize}
%    \item The validation of the implemented simulator
%    \item LISP-MN handover analysis
%    \item The potential of the implemented simulator
%\end{itemize}
% As a promising technology for the future Internet architecture, LISP attracts more and more attention. 
There exist some LISP simulation implementations, but they are proprietary or they do not support the extension of LISP mobility. Further, although measurements on LISP-testbeds can provide real time performance, due to the complicated topological structure, it is somewhat like a black box test, which hinders us to find the exact explanation for some results. This highlights the importance to have an open source simulator for LISP in particular to support LISP mobility functionality. In this chapter, based on an implementation of basic LISP on ns-3.24, we adapt it to ns-3.27 first (the latest version at the moment of writing). To facilitate the researchers to deeply track the exchange of LISP packets, we encode in LISP Data Plane packets so that the Wireshark can resolve them. Finally we implement the LISP mobility extensions on it. As there are three methods to support mobility in LISP: host-based (i.e. LISP-MN), network-based (i.e., xTR), both host-based and network-based (i.e., LISP-MN behinds xTR) mobility. We analyze the overall handover delay and the overhead of LISP control plane among them, compare the performance among them by listing their advantages and shortcomings. % The simulation results show that our implementation works well, and reveal the current LISP-MN proposal with a double encapsulation that has an high level delay during handover procedure. Our simulator can be a perfect choice to test the improvements of LISP-MN.


