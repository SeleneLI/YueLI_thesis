%*******************************************************************************
%****************************** Sixth Chapter *********************************
%*******************************************************************************

\chapter{ns-3 Implementation of LISP and LISP-MN}
\label{cha:ns-3}

% **************************** Define Graphics Path **************************
\ifpdf
    \graphicspath{{Chapter7/Pics/Raster/}{Chapter7/Pics/PDF/}{Chapter7/}}
\else
    \graphicspath{{Chapter7/Pics/Vector/}{Chapter7/}}
\fi

%-< ABSTRACT >--------------------------------------------------------------------
The \emph{Locator/Identifier Separation Protocol} (LISP) reconstructs the current IP addressing space so to be able to improve the no interrupt mobility issues. LISP Mobile Node (LISP-MN) is based on the basic LISP functionality to provide seamless mobility across networks. Thus, LISP can be implemented either on the border routers or directly on the end hosts to achieve the mobility. However, there are no experimental results comparing the advantages and disadvantages of each solution. The basic LISP architecture is deployed on LISP Beta Network and LISP-Lab platform to offer the researchers a realistic experimental environment, but both do not support LISP-MN. Some simulation models with LISP extensions are implemented on various simulators, but are not open source. Fortunately, there is an open source project implementing the fundamental LISP on ns-3 in 2016. Providing a free and flexible simulation model with the extensions so to help researchers quickly test new LISP mobility behaviors motivates our work. This chapter analyzes the different LISP mobility scenarios from the respects of handover delay and overhead of control plane. It describes the characteristics of each scenario. In addition, this chapter introduces the implementation of basic LISP architecture model and LISP-MN on the simulator ns-3. % It also provides the evaluation results in mobility scenario to validate the model and shows when the current proposal of LISP-MN is behind a LISP-site has a very high delay during the handover procedure.

The rest of chapter is organized as follows: Sec.~\ref{sec:ns3_related_work} introduces ns-3 and the existing LISP simulator on it. Sec.~\ref{sec:ns3_lispmn} analyzes the design and implementation of our prototype, and afterwards, Sec.~\ref{sec:ns3_analysis} illustrates three different LISP scenarios supporting seamless mobility, presents their traffic schema, modelizes the handover delay and overhead of control plane, and compares their advantages and disadvantages. % Sec.~\ref{sec:evaluation} presents preliminary evaluation results of our implementations. 
Sec.~\ref{sec:ns3_conclusion} provides some ideas of evaluation based on the proposed simulation for future work.
%-< ABSTRACT >--------------------------------------------------------------------

%-< SUB SECTION >--------------------------------------------------------------------
\section{Related work}
\label{sec:ns3_related_work}
 \subsection{Description of ns-3}
 \label{sec:ns3_ns3}
 ns-3~\cite{ns3} is a popular and free discrete-event network simulator for networking research. To be closer to the real implementation (in a real Operating System), easily include C-based implementation codes, ease debugging and reduce the cost on maintaining in a long term, C++ is prioritized to be the unique programming language for ns-3. Besides, ns-3 offers the possibility to visualize the simulation instance so to allow the users to visually confirm the packets flow as they expect.
%\begin{itemize}
%    \item Description of ns-3.
%    \item The simulator supporting LISP is introduced in Sec.~\ref{subsec:implementation_OMNet}.
%\end{itemize}



The detailed simulation model is based on NS-3 (version 3.27, the latest version). The NS3 simulator is developed and distributed completely in the C++ programming language, because it better facilitated the inclusion of C-based implementation code. The NS3 architecture is similar to Linux computers.

%-< SUB SECTION >--------------------------------------------------------------------
\subsection{Basic LISP implementation on ns-3}
\label{sec:ns3_basic_lisp}
It should be noted that this work is based on a prior implementation work by Lionel. However, his implementation has no support for LISP MN.


%-< SECTION >--------------------------------------------------------------------
\section{Implementation of LISP and LISP-MN on ns-3}
\label{sec:ns3_lispmn}
Our implementation is under ns-3.27 and respects LISP~\cite{rfc6830} and LISP-MN standards~\cite{meyer2016lisp}. As a design choice, we implement LISP/LISP-MN functionalities by modifying and extending two already existing modules of ns-3:~\emph{internet} and \emph{internet-apps}, instead of by creating a new independent module. The justification behind this design is that LISP/LISP-MN and legacy internet module have an interdependent relationship: a IP layer packet is processed by LISP and then passed to IP protocol again. However, this kind mutually dependent relationship between modules is not supported by ns-3. Our implementation mainly consists of two parts: Data plane and Control plane. The communication between LISP Data and Control Plane is achieved via a dedicated socket (i.e. \emph{LispMappingSocket}) that inherits from ns-3 \emph{Socket} class. The Data Plane implementation is in "kernel space" (i.e. ns-3's \emph{TCP/IP stack}) and Control Plane is implemented in "user space" (i.e. ns-3 \emph{Application}). Such a design is inspired by that of OpenLISP~\cite{saucez2009openlisp}.  

The UML diagram of proposed LISP and LISP-MN implementation is illustrated Fig.~\ref{LISP-UML}. The blank blocks refer to the classes that we added into ns-3, while darker blocks are classes already in ns-3. It should be noted that our implementation only supports IPv4 at time of this writing. The IPv6 support (i.e. the implementation related to IPv6 such as \emph{LispOverIpv6Impl}) is still in process. In addition, the authentication procedure involved in LISP is not considered in our implementation.\yue{This figure should be revised. For example, LispHeader should be renamed as LispDataPlaneHeader. MapTable should contains a list of MapEntry.}
%-< FIGURE >--------------------------------------------------------------------
\begin{figure*}[!t]
	\centering
	\includegraphics[width=\textwidth]{Pics/LISP-NS3-UML}
	\caption{UML diagram of LISP/LISP-MN implementation. The solid arrow refers to a composition relation, while the blank one refers to a inheritance relation.}
	\label{LISP-UML}
\end{figure*}
%-< END FIGURE >--------------------------------------------------------------------
%-< SUB SECTION >--------------------------------------------------------------------
\subsection{Implementation of LISP Data Plane}
\label{subsec:modifyInternet}
%\begin{itemize}
%    \item Modification of Receive method
%    \item Modification of Delivery method
%    \item Implementation of LISP encapsulation and decapsulation
%\end{itemize}
The implementation of LISP Data plane mainly consists of \emph{LispOverIp} and \emph{MapTable} classes and their subclasses, along side with some auxiliary classes (e.g. \emph{LispHeader}). In addition, To support LISP functionalites, the \emph{Ipv4L3Protcol}, which is the IP protocol implementation in ns-3, contains one \emph{LispOverIp} object and \emph{Ipv4L3Protcol}'s packet transmission, reception, forward and delivery procedures are accordingly adapted.
\subsubsection{LISP Database and cache}
\label{subsec:database-impl}
Each LISP-speaking node should maintain one LISP database and LISP cache for LISP encapsulation and decapsulation operations. In our implementation, both LISP database and cache are modellized by the same class~\emph{MapTable} that stores and manages EID-RLOC mapping information. This class is in charge of CRUD (Create, Retrieve, Update, Delete) operations for mappings. Each mapping entry in LISP database and cache is an instance of \emph{MapEntry}. For the sake of flexibility, the class \emph{MapTable} is an abstract base class. The CRUD methods are implemented in its subclass \emph{BasicMapTable}. The mapping search operation is a straightforward iteration over LISP database or cache. It is possible that for other users to provide their own LISP database and cache implementation, for example, which employs more sophisticated mapping entry look up algorithms, by extending \emph{MapTable} class.

In addition, \emph{MapTable} has a callback which allows to send the buffered packet (either LISP data plane or control plane) due to LISP cache miss event, upon insertion of the required EID-RLOC mapping information into LISP cache.

\subsubsection{Implementation of LISP encapsulation and decapsulation}
A LISP-compatible node (terminal or router) should be capable of determining whether a packet should be passed to LISP-related procedure and retrieving the associated mapping information if necessary. To this end, a new class called \emph{LispOverIp} and its extended classes (refer to Fig.~\ref{LISP-UML}) are added to ns-3 \emph{internet} module. This class is in charge of checking whether necessary to do LISP-related operations (\emph{NeedEncapsulation()}, \emph{NeedDecapsulation()}), and encapsulating conventional IP packets (i.e., \emph{LispOutput()}) as well as decapsulating LISP packets(\emph{LispInput()}). It also contains a smart pointer pointing to the LISP database and LISP cache, namely an instance of \emph{MapTable}. This class cooperates with \emph{Ipv4L3Protcol} to implement LISP and LISP-MN.

We take an example to illustrate how LISP encapsulation and decapsulation is implemented. We assume that LISP-MN node has enough mapping information in its database and cache.
Imagining we have a LISP-MN node behind a xTR router need to communicate with CN before another xTR router. The example involves packet transmission, forwarding, reception, which is illustrated by Fig.\yue{Remember to add a figure here}. When upper layer calls the \emph{send()} method of \emph{Ipv4L3Protcol},a packet comes down to IP layer. The \emph{send()} method is adapted so that    
it first verifies whether the \emph{LispOverIp} object is present. If yes, some checks are then conducted to determine that this packet should be processed by \emph{LispOutput()} (to encapsulate the packets) or by conventional packet transmission routine. For example, if both source and destination IP address of this packet belong to the same network, the LISP-related process (e.g., encapsulation) is skipped and this packet is processed as in a non-LISP network. Otherwise, EID-RLOC mapping information is searched from LISP cache and LISP database on LISP-MN node. 



When the considered packet is forwarded to xTR1, This procedure is illustrated in Fig.~\yue{Add one figure here}. Low layer invokes the \emph{Receive} method of \emph{Ipv4L3Protocol} to pass this packet to IP layer. Since this packet is destinated to a remote CN instead of itself, this packet is processed by patched \emph{IpForward} method. , \emph{IpForward} method of \emph{Ipv4L3Protocol} is called. With this method, LISP encapsulation is verified. LispOverIp looks for source RLOC (RLOC of xTR1) and destination RLOC (RLOC of xTR2) for the outter IP header building. Once this step is done, Ipv4L3Protocol's send method transmits these encapsulated packet to MAC layer for transmission.

When this packet arrives at xTR2, xTR2 finds that the destination of this packet is the node itself, the packet is processed by \emph{LocalDelivery} method in \emph{Ipv4L3Protocol}. Before passing to transport layer, \emph{LocalDelivery} checks if the packet should be decapsulated. If yes, it is passed to \emph{LispInput} method, in which the packet is decapsulated and reinjected in the IP stack. That is to say, \emph{Receive} method is called again after decapsulation operation. If the packet sitll has LISP header, the aforementioned procedure will repeated until it has no need to be decapsulated.

%-< SUB SECTION >--------------------------------------------------------------------
\subsection{Implementation of LISP Control Plane}
\label{subsec:control-plane-impl}
%\begin{itemize}
%    \item Implementation of xTR under ns3
%    \item Implementation of MS under ns3
%    \item Socket communication between control plan and data plan
%\end{itemize}
The implementation of LISP Control Plane at least should provide ITR/ETR, MR and MS. In practice, ETR and ITR functionalities are usually placed on a same router. In our implementation, they are included into classs \emph{LispEtrItrApplication}.
The functionalities of MS and MR are respectively implemented by class \emph{MapServer} and \emph{MapResolver}. The LISP Control plane messages (map register, map request, etc.) are represented by the derived classes of \emph{LispControlMsg}). In addition, to communicate with LISP data plan, a socket class \emph{LispMappingSocket} is proposed.

In case of cache missing (i.e. destination RLOC is not found in the cache), the packet is dropped and \emph{SendNotifyMessage()} in \emph{LispOverIp} notifies the \emph{LispEtrItrApplication} that runs on LISP-MN node via a \emph{LispMappingSocket} socket. Once reception of cache missing event from LISP Data Plane (i.e. \emph{LispOverIp} object), \emph{LispEtrItrApplication} initiates a Map-Request message to LISP mapping system. Once reception of Map-Reply, the received EID-RLOC mapping is inserted into LISP cache. It should be noted that as an implementation choice, before the reception of Map-Reply message, all transmitted packets with the required RLOC as desination are dropped. One can also design a buffer to queue these packets and resend them once the required mapping informtion is received via Map-Reply. The advantage of such an implementation is to reduce the packet loss rate.

 A ns-3 node that runs \emph{LispEtrItrApplication} is a LISP-compatible router. It should be able to communicate with \emph{LispOverIp} on the same node (e.g. inform cache missing event) and other LISP-compatible routers (e.g. Map-Request/Map-Reply). 
 
 To support LISP-MN feature, \emph{LispEtrItrApplication} also communicates with DHCP client application. For example, once a LISP-MN obtains an IP address from DHCP server, \emph{LispEtrItrApplication} receives the corresponding EID-RLOC mapping and sends a Map-Register message~\cite{meyer-lisp-mn-16}.

A node that runs a \emph{MapServer} application is the MS in a LISP-supported network. This class maintains a LISP database to store the EID-RLOC mapping information, learned from Map-Register message at the initialization stage. In current implementation, the role of MR is to receive the Map-Request message from xTR and forward it to the MS.

%-< SUB SECTION >--------------------------------------------------------------------
\subsection{Integration of TUN net interface card}
\label{subsec:tundevice}
To support mobility, LISP-MN actually can be regarded as a small LISP-Site, in which xTR functionalities and DHCP service are implemented, as well as configured address of MR and MS. As a LISP-MN node, it has a static permanent EID and dynamic RLOC assigned by the DHCP server. To differentiate with conventional RLOC of xTR interface, such kind of RLOC is referred to as the local RLOC (LRLOC). Different from conventional LISP node, at least two net interface cards (NIC) are installed into LISP-MN. One is \emph{WifiNetDevice}, the other is a TUN type card. The DHCP client application runs on LISP-MN's \emph{WifiNetDevice} and thus the LRLOC is allocated to this card. The permanent EID is assigned to \emph{VirtualNetDevice} net card. We modify the node's routing table so that each packet's inner header contains IP address on \emph{TunNetDevice} and outer header contains IP address of \emph{WifiNetDevice} as source address.

%-< SUB SECTION >--------------------------------------------------------------------
\subsection{Integration of DHCP}
\label{subsec:DHCP}
%\begin{itemize}
%    \item LISP-MN, in case of IPv4, need the intervention of DHCP procedure
%    \item The current version of DHCPv4 is not compatible with LISP
%    \item Implementation of LISP-compatible DHCPv4 based on conventional DHCPv4
%\end{itemize}
To support mobility within conventional LISP node, a modified DHCP client application is integrated into ns-3 node. To be compatible with LISP functionality, DHCP client application is modified. Once the DHCP client receives an allocated IP address (i.e. LRLOC), it notifies the \emph{LispEtrItrApplication} (i.e. LISP Control Plane) by sending a dedicated message that contains the EID-LRLOC mapping. \emph{LispEtrItrApplication} is in charge of populating the received mapping entry into LISP database. During the mobility process, when wireless link is down, the DHCP client flushes the LISP-MN database and populates the database again once reception of new LRLOC. 

% To support DHCP, conventional LISP-related process is also modified. For example, to transmit a DHCP Discovery message (application layer message), its source IP address is set as $0.0.0.0$. This message should be not processed by and should not passed to \emph{LispOutput} in \emph{LispOverIp}.


%-< SECTION >--------------------------------------------------------------------
\section{Theoretical analysis}
\label{sec:ns3_analysis}
As no matter LISP implemented on the border router or the end host can support seamless mobility, we design three different scenarios in this chapter to illustrate their characteristics, calculate their handover delay and overhead of control plane. 
%-< FIGURE >--------------------------------------------------------------------
\begin{figure}[!th]
	\centering
	\includegraphics[width=0.8\textwidth]{Pics/LISP_mobility_archi}
	\caption{General scenario for LISP mobility architecture}
	\label{sim_archi}
\end{figure}
%-< END FIGURE >--------------------------------------------------------------------
\begin{enumerate}[noitemsep,topsep=0pt]
	\item The first scenario is LISP-MN in the non-LISP-Site (i.e., only the end host supports LISP). 
	\item The second one is MN in the LISP-Site (i.e., only the border router supports LISP). 
	\item The last scenario is LISP-MN in the LISP-Site (i.e., both the border router and the end host support LISP). 
\end{enumerate}	
% -<Descriptions with parameters>--------------------------------------------------------------------
% All the scenarios are based on a same simulation architecture shown in Fig.~\ref{sim_archi}, but with some slight differences, which will be respectively specified in the following parts from Sec.~\ref{sec:ns3_analysis_lispmn} to Sec.~\ref{sec:ns3_analysis_lispmn_xTR}. In our designed architecture, an MN is initially in the subnet of $Router_1$. An \emph{echo} application on MN sends packets to a remote stationary node CN in the LISP-Site of $xTR_3$. The distance between xTR\_1 and xTR\_2 is $170 m$. The connection between MN and xTR\_1 can be either Wi-Fi or wired link. If they use Wi-Fi, MN will move into the subnet of $Router_2$ at speed of $7.07 m/s$ after several seconds when the simulation begins. The start time of movement is a random value in the range of $[x, x] s$. At a certain moment during the moving, the Wi-Fi link between MN and $Router_1$ is down, which triggers the handover procedure. Afterwards, MN connects to $Router_2$ and reestablishes the communication with CN node. If they use wired link, the connection of MN with $Router_1$ will be down and the one with $Router_2$ will be up at the same time. This action also triggers the handover procedure. Every link between two network entities in this simulation architecture is set to $20 ms$.

All the scenarios are based on a same simulation architecture shown in Fig.~\ref{sim_archi}, but with some slight differences, which will be respectively specified in the following parts from Sec.~\ref{sec:ns3_analysis_lispmn} to Sec.~\ref{sec:ns3_analysis_lispmn_xTR}. In our designed architecture, an MN is initially in the subnet of $Router_1$. An \emph{echo} application on MN sends packets to a remote stationary node CN in the LISP-Site of $xTR_3$. The connection between MN and $Router_1$ can be either Wi-Fi or wired link. If they use Wi-Fi, MN will move into the subnet of $Router_2$ after several seconds when the simulation begins. At a certain moment during the moving, the Wi-Fi link between MN and $Router_1$ is down, which triggers the handover procedure. Afterwards, MN connects to $Router_2$ and reestablishes the communication with CN node. If they use wired link, the connection of MN with $Router_1$ will be down and the one with $Router_2$ will be up at the same time. This action also triggers the handover procedure.

In this chapter, we define the overall handover delay ($D_{overall}$) as the latency between the last packet received by MN from CN via $Router_1$ and the first packet received by MN from CN via $Router_2$ after the reestablishment. Same to the calculation of overall handover overhead ($C_{overall}$), which is the number of signals related to LISP control plane during that latency. According to the three following scenarios, the handover delay and overhead consist of different parts. All the necessary delay and LISP overhead of control plane during the mobility are listed in Tab.~\ref{Symbols_numerical_analysis}.
%-< TABLE >-----------------------------------------------------------------
\begin{table}[!tb]
	\centering
	\caption{Symbols for numerical analysis}
	\label{Symbols_numerical_analysis}{
		% \resizebox{0.9\textwidth}{!}{%
		\begin{tabular}{@{}|c|c|@{}}
			\hline\hline
			Symbols & Explanations   \\ \hline
			$D_{overall}$ & Overall handover delay	\\  \hline    
			$D_{DHCP}$ &  DHCP address configuration delay \\  \hline    
			$D_{Register}$ &  Delay of sending Map-Register      	\\  \hline
			$D_{Notify}$ &  Delay of receiving Map-Notify      	\\  \hline           
			$D_{Request}$ &  Delay of sending Map-Request to MDS      	\\  \hline   
			$D_{Reply}$ &  Delay of receiving Map-Reply      	\\  \hline      
			$D_{Resolve}$ &  Delay of resolving mapping information in MDS      	\\  \hline               
			$D_{SMR}$ &  Delay of sending SMR       	\\  \hline 
			$D_{invokeSMR}$ &  Delay of sending invoke-SMR \\  \hline 
			$D_{Link}$ &  Link delay between two network entities \\  \hline 
			$T_{A-B}$ &  Delay of packet transmission between A and B     	\\  \hline
			$T_{timeout_SMR}$ &  Timeout of SMR      	\\  \hline
			$C_{overall}$ &  Overall handover overhead \\  \hline    
			$C_{Register}$ &  Overhead of sending Map-Register      	\\  \hline
			$C_{Notify}$ &  Overhead of receiving Map-Notify      	\\  \hline           
			$C_{Request}$ &  Overhead of sending Map-Request to MDS      	\\  \hline   
			$C_{Reply}$ &  Overhead of receiving Map-Reply      	\\  \hline      
			$C_{SMR}$ &  Overhead of sending SMR       	\\  \hline 
			$C_{invokeSMR}$ &  Overhead of sending invoke-SMR \\  \hline  \hline    
		\end{tabular}
	}
\end{table}
%-< END TABLE >-----------------------------------------------------------------



%-< SUBSECTION >--------------------------------------------------------------------
\subsection{LISP-MN in non-LISP-Site}
\label{sec:ns3_analysis_lispmn}
The first scenario is the LISP-MN in non-LISP-Site, where the border routers are the conventional routers and LISP is only implemented on the mobile end host MN. In our simulation, the LISP-MN with permanent EID is initially placed in the subnet of $Router_1$, with the IP address distributed by $Router_1$ as its RLOC. The remote CN is a conventional stationary end host, residing in a LISP-Site of $xTR_3$. The LISP-MN communicates with CN by encapsulating the packets on itself and decapsulating the packets on $xTR_3$. If we use Wi-Fi, the LISP-MN moves into subnet of $Router_2$ after the simulation begins. At a certain moment during the moving, the Wi-Fi link between LISP-MN and $Router_1$ is down, whereas LISP-MN detects $Router_2$, which triggers the handover procedure. If we use wired link, after a certain time that the simulation begins, we turn down the wired link between LISP-MN and $Router_1$, while set the link between LISP-MN and $Router_2$ up at the same time. LISP-MN first has a DHCP procedure with $Router_2$, so that the later distributes it a new IP address as its RLOC. Then LISP-MN needs register its new mapping information to the mapping system, and also send a $SMR$ to its communicating nodes in its cache (there is only $xTR_3$ in our scenario). $xTR_3$ sends an $Invoke SMR$ to the mapping system, so to obtain the new mapping information of LISP-MN. Afterwards, LISP-MN reestablishes the communication with CN node leveraging $Router_2$. The detailed traffic schema related to the handover procedure is indicated in Fig.~\ref{sim_schema_LISPMN}.  % The total simulation time is set to $45s$ and the DHCP procedure delay is set to $1s$. We conduct many times of simulations with the various beacon interval of Wi-Fi channel in the range of $0.05s$ to $2s$.
%-< FIGURE >--------------------------------------------------------------------
\begin{figure}[!th]
	\centering
	\includegraphics[width=0.8\textwidth]{Pics/Mobility_LISPMN_schema_SMR_simplify}
	\caption{Schema for LISP-MN mobility}
	\label{sim_schema_LISPMN}
\end{figure}
%-< END FIGURE >--------------------------------------------------------------------

The overall handover delay $D_{overall}$ in this scenario is composed by two parts: the DHCP related delay and LISP related delay. The delay of DHCP procedures consist of LISP-MN sending DHCP Discovery message to $Router_2$, receiving DHCP Offer message, sending DHCP Request message, and receiving DHCP ACK message. The delay of all the LISP procedures are presented in Fig.~\ref{sim_schema_LISPMN}. Thus, the overall handover delay is:
\begin{eqnarray}
D_{overall} &=& D_{DHCP} + D_{Register} + D_{Notify} + D_{SMR} + D_{invokeSMR} + D_{Reply} \nonumber \\
% &=& D_{DHCP} + T_{MN-MDS} + T_{MDS-MN} + T_{MN-xTR_3} + (T_{xTR_3-MDS} + D_{Resolve} + T_{MDS-MN}) + T_{MN-xTR_3} \nonumber \\
&=& D_{DHCP} + 3T_{MN-MDS} + 2T_{MN-xTR_3} + T_{xTR_3-MDS} + D_{Resolve} \nonumber \\
&=& D_{DHCP} + 3* (3*D_{Link}) + 2*(3*D_{Link}) + 2*D_{Link} + 200ms\nonumber \\
% &=& D_{DHCP} + 3* (3*2ms) + 2*(3*2ms) + 2*2ms + 200ms \nonumber \\
&=& D_{DHCP} + 17D_{Link} + 200 ms  \\
&=& D_{DHCP} + 234 ms \nonumber
\end{eqnarray}
where $D_{DHCP}$ represents the time elapsed between the DHCP Discover sent by the LISP-MN, and the $DHCP ACK$ message sent by the $Router_2$. Every link between two network entities in this simulation architecture is set to $2 ms$. According to the experimental results in~\cite{coras2014performance}, we set the resolving time in the mapping system as $200 ms$. % (Min value of handover delay = 1.073031 s, where packet sending interval = 0.01 s)

The overall handover overhead $C_{overall}$ includes the signaling overhead of registration when LISP-MN connects to $Router_2$, and the SMR procedure. Thus, the overall handover overhead related to LISP control plane is:
\begin{eqnarray}
C_{overall} &=& C_{Register} + C_{Notify} + C_{SMR} + C_{invokeSMR} + C_{Reply} \nonumber \\
&=& C_{Register} + C_{Notify} + C_{SMR} + 2C_{Request} + C_{Reply} \nonumber \\
&=& 6 C
\end{eqnarray}

There are two options when $xTR_3$ receives $SMR$. It can send the Invoke SMR to the mapping system as we described before, or it can directly send the Invoke SMR to the source locator address of $SMR$~\cite{rfc6830}. In this scenario, the source of $SMR$ is LISP-MN. Thus, the numerical analysis of overall handover delay $D_{overall}$ is as follows:
\begin{eqnarray}
D_{overall} &=& D_{DHCP} + D_{Register} + D_{Notify} + D_{SMR} + D_{invokeSMR} + D_{Reply} \nonumber \\
% &=& D_{DHCP} + T_{MN-MDS} + T_{MDS-MN} + T_{MN-xTR_3} + T_{xTR_3-MN} + T_{MN-xTR_3} \nonumber \\
&=& D_{DHCP} + 2T_{MN-MDS} + 3T_{MN-xTR_3}  \nonumber \\
&=& D_{DHCP} + 2* (3*D_{Link}) + 3*(3*D_{Link}) \nonumber \\
% &=& D_{DHCP} + 2* (3*2ms) + 3*(3*2ms) \nonumber \\
&=& D_{DHCP} + 15D_{Link}  \\
&=& D_{DHCP} + 30 ms \nonumber
\end{eqnarray}
Compared to sending Invoke SMR to the mapping system, the overall handover delay of sending the Invoke SMR back to the source of $SMR$ is much smaller, since there is no resolving delay in the mapping system. This solution is more interesting for the case that the distance to mapping system is much longer than that to the source of $SMR$.

The overall handover overhead $C_{overall}$ is:
\begin{eqnarray}
C_{overall} &=& C_{Register} + C_{Notify} + C_{SMR} + C_{invokeSMR} + C_{Reply} \nonumber \\
&=& C_{Register} + C_{Notify} + C_{SMR} + C_{Request} + C_{Reply} \nonumber \\
&=& 5 C
\end{eqnarray}

The advantages of this scenario, i.e., LISP-MN in non-LISP-Site, are: 
\begin{inparaenum}[1)]
	\item it is able to achieve seamless handover through different subnets;
	\item the numerical analysis indicates that the overall handover delay is small;
	\item so to the overall overhead. The mobility does not cause lots of traffic in LISP control plane.
\end{inparaenum}
However, since the routers are still the normal routers in this scenario, it can not help to reduce the BGP routing table size, which is the initial purpose to motivate LISP. Moreover, each LISP-MN needs a permanent IP address as its EID, which increases the burden of IPv4 address distribution. Each permanent EID and its RLOC needs register to the mapping system, which also increases the size of LISP mapping table.

%-< SUBSECTION >--------------------------------------------------------------------
\subsection{MN in LISP-Site}
\label{sec:ns3_analysis_xTR}
The second scenario is the MN in LISP-Site, where the mobile node MN is conventional and LISP are only implemented on the border routers. In our simulation, the MN is initially placed in the subnet of $xTR_1$, with the distributed IP address as its EID. The remote CN is same to the first scenario. The MN communicates with CN by encapsulating the packets on $xTR_1$ and decapsulating the packets on $xTR_3$, and the MN moves into the coverage of $xTR_2$ after the simulation begins. Since the communication should not be interrupted during the mobility, this scenario limits the movement of MN being only within the same subnet, i.e., one of the EID-prefixes of $xTR_1$ is same to one of $xTR_2$'s. At a certain moment during the moving, the Wi-Fi link between MN and $xTR_1$ is down, whereas MN detects $xTR_2$, which triggers the switching connection procedure. If we use wired link, after a certain time that the simulation begins, the wired link between MN and $xTR_1$ is down, meanwhile the link between MN and $xTR_2$ is up. Same to the first scenario, the DHCP procedure is necessary so to trigger the registration of new mapping information, but MN still keeps the former IP address as its EID, instead of $xTR_2$ distributing a new one to it. Then $xTR_2$ registers its new mapping information to the mapping system. As the mapping system find out that the EID of MN has been registered and associated by $xTR_1$, it sends a Map-Notify to both xTRs. The reason for sending to $xTR_2$ is the acknowledgment of the reception of its Map-Register. Whereas the purpose to $xTR_1$ is to tell it that the MN is now mapping with $xTR_2$ and inform the remote CN to update its mapping information. Since MN used $xTR_1$ to communicate with CN in the past time, only $xTR_1$ stored in its cache that to whom MN was exchanging the packets instead of $xTR_2$. Thus, $xTR_1$ sends a $SMR$ to $xTR_3$, and $xTR_3$ sends an $Invoke SMR$ to the mapping system, so to obtain the new mapping information of MN. Afterwards, MN reestablishes the communication with CN node leveraging $xTR_2$. The detailed traffic schema related to the handover procedure is indicated in Fig.~\ref{sim_schema_xTR}.
%-< FIGURE >--------------------------------------------------------------------
\begin{figure}[!th]
	\centering
	\includegraphics[width=0.8\textwidth]{Pics/Mobility_xTR_schema_SMR_simplify}
	\caption{Schema for LISP-MN mobility}
	\label{sim_schema_xTR}
\end{figure}
%-< END FIGURE >--------------------------------------------------------------------

The overall handover delay $D_{overall}$ in this scenario is generally same to the first one but has slight difference. The numerical analysis is as follows:
\begin{eqnarray}
D_{overall} &=& D_{DHCP} + D_{Register} + D_{Notify} + D_{SMR} + D_{invokeSMR} + D_{Reply} \nonumber \\
% &=& D_{DHCP} + T_{xTR_2-MDS} + T_{MDS-xTR_1} + T_{xTR_1-xTR_3} + T_{xTR_3-MDS} + D_{Resolve} + T_{MDS-xTR_2} + T_{xTR_2-xTR_3} \nonumber \\
&=& D_{DHCP} + 2T_{xTR_2-MDS} + T_{MDS-xTR_1} + T_{xTR_1-xTR_3} + T_{xTR_3-MDS} + \nonumber \\
& & D_{Resolve} + T_{xTR_2-xTR_3} \nonumber \\
&=& D_{DHCP} +2* (2*D_{Link}) + 2*D_{Link} + 2*D_{Link} + 2*D_{Link} + 200ms + 2*D_{Link} \nonumber \\
% &=& D_{DHCP} +2* (2*2ms) + 2*2ms + 2*2ms + 2*2ms + 200ms + 2*2ms \nonumber \\
&=& D_{DHCP} + 12D_{Link} + 200 ms  \\
&=& D_{DHCP} + 224 ms \nonumber
\end{eqnarray}
% $CheckAlive$ is the delay that xTR\_1 checks if MN still connects to it. For example, xTR\_1 can simply \emph{ping} MN. If MN still connects to it, it will reply to mapping system that itself is still RLOC of MN. Otherwise, if \emph{ping} meets timeout, xTR\_1 will tell the mapping system that MN has left, and sends SMR to the CNs in its cache. The later situation has higher delay, because xTR\_1 needs to wait until timeout of \emph{ping}. % (Min value of simulation = 1.067679 s, where includes 1 s of DHCP delay)

The overall handover overhead $C_{overall}$ is:
\begin{eqnarray}
C_{overall} &=& C_{Register} + 2C_{Notify} + C_{SMR} + C_{invokeSMR} + C_{Reply} \nonumber \\
&=& C_{Register} + 2C_{Notify} + C_{SMR} + 2C_{Request} + C_{Reply} \nonumber \\
&=& 7 C
\end{eqnarray}

Same to the first scenario having two options, when $xTR_3$ receives the $SMR$ from $xTR_1$, it can also directly send Invoke SMR back to $xTR_1$. The overall handover delay $D_{overall}$ is as follows:
\begin{eqnarray}
D_{overall} &=& D_{DHCP} + D_{Register} + D_{Notify} + D_{SMR} + D_{invokeSMR} + D_{Reply} \nonumber \\
% &=& D_{DHCP} + T_{xTR_2-MDS} + T_{MDS-xTR_1} + T_{xTR_1-xTR_3} + T_{xTR_3-xTR_2} + T_{xTR_2-xTR_3} \nonumber \\
&=& D_{DHCP} + T_{xTR_2-MDS} + T_{MDS-xTR_1} + T_{xTR_1-xTR_3} + 2T_{xTR_2-xTR_3} \nonumber \\
&=& D_{DHCP} +2*D_{Link} + 2*D_{Link} + 2*D_{Link} + 2*(2*D_{Link}) \nonumber \\
% &=& D_{DHCP} +2*2ms + 2*2ms + 2*2ms + 2*(2*2ms) \nonumber \\
&=& D_{DHCP} + 10D_{Link}  \\
&=& D_{DHCP} + 20 ms \nonumber
\end{eqnarray}
Since the Invoke SMR is not sent to the mapping system, there is no resolving delay, and the overall handover delay is much smaller than the former solution. However, in this scenario, as $xTR_1$ has not been in charged of MN, how long it stores the CNs for MN in its cache is an important point to discuss. If the expired time is set too long, it wastes the source of $xTR_1$ and is not necessary. Whereas if the time is too short, there is the risk that remote CNs like $xTR_3$ in our scenario, do not have enough time to request the new mapping information.

The overall handover overhead $C_{overall}$ is:
\begin{eqnarray}
C_{overall} &=& C_{Register} + 2C_{Notify} + C_{SMR} + C_{invokeSMR} + C_{Reply} \nonumber \\
&=& C_{Register} + 2C_{Notify} + C_{SMR} + C_{Request} + C_{Reply} \nonumber \\
&=& 6 C
\end{eqnarray}

Since the routers support LISP, i.e., are the xTRs in this scenario, it can help to reduce the BGP routing table size, which is the fundamental motivation of proposing LISP. Besides, the numerical analysis presents that the overall handover delay of this scenario is the shortest. However, it can only provide the mobility within a same subnet without any interrupt, but it is not able to offer the seamless handover through different subnets. Thus, this scenario is more suitable to be applied for the mobility of virtual machines in the Data Center.

%-< SUBSECTION >--------------------------------------------------------------------
\subsection{LISP-MN in LISP-Site}
\label{sec:ns3_analysis_lispmn_xTR}
The third scenario is the LISP-MN in LISP-Site, where both the border routers and the mobile node MN are implemented LISP. In our simulation, the LISP-MN with permanent EID is initially placed in the subnet of $xTR_1$, with the IP address distributed by $xTR_1$ as its LRLOC. The remote CN is still same to the first two scenario, which is a conventional stationary end host, residing in a LISP-Site of $xTR_3$. The LISP-MN communicates with CN by double encapsulation. The first encapsulation is on itself and the second time is on the $xTR_1$. When the LISP packets arrive at $xTR_3$, it needs decapsulate them twice. If we use Wi-Fi, the LISP-MN moves into subnet of $xTR_2$ after the simulation begins. At a certain moment during the moving, the Wi-Fi link between LISP-MN and $xTR_1$ is down, whereas LISP-MN detects $xTR_2$, which triggers the handover procedure. If we use wired link, after a certain time that the simulation begins, we turn down the wired link between LISP-MN and $xTR_1$, while set the link between LISP-MN and $xTR_2$ up at the same time. LISP-MN first has a DHCP procedure with $Router_2$, so that the later distributes it a new IP address as its LRLOC. Then LISP-MN needs register its new mapping information to the mapping system, and also send a $SMR$ to all the CNs in its cache (there is only $xTR_3$ in our scenario). Once $xTR_3$ receives a $SMR$, it sends an $Invoke SMR$ to the mapping system, so to obtain the new mapping information of LISP-MN. Actually this mapping information that $xTR_3$ obtains is the $<EID_LISPMN, LRLOC>$ for LISP-MN. It is not able to send the packets to LISP-MN at the moment, since it does not know the RLOC of LRLOC. Only until $xTR_3$ receives the packets from CN to LISP-MN, which triggers the Map-Request procedure to the mapping system, can $xTR_3$ know the double mapping information for LISP-MN. Afterwards, LISP-MN reestablishes the communication with CN node by passing $xTR_2$. The detailed traffic schema related to the handover procedure is indicated in Fig.~\ref{Mobility_double_encap_schema_SMR_askMDS_simplify}.
%-< FIGURE >--------------------------------------------------------------------
\begin{figure}[!th]
	\centering
	\includegraphics[width=0.8\textwidth]{Pics/Mobility_double_encap_schema_SMR_askMDS_simplify}
	\caption{Schema for LISP-MN in LISP-Site mobility}
	\label{Mobility_double_encap_schema_SMR_askMDS_simplify}
\end{figure}
%-< END FIGURE >--------------------------------------------------------------------

Since this scenario is double encapsulation that $xTR_3$ needs to know both inner and outer mapping information of LISP-MN for sending the packets. The overall handover delay $D_{overall}$ in this scenario is larger than the first two scenarios. The numerical analysis is as follows:
\begin{eqnarray}
D_{overall} &=& D_{DHCP} + D_{Register} + D_{Notify} + D_{SMR} + D_{invokeSMR} + D_{Reply} +  \nonumber \\
& & D_{Request}+ D_{Reply} \nonumber \\
% &=& D_{DHCP} + 2T_{MN-MDS} + T_{MN-xTR_3} + T_{xTR_3-MDS} + D_{Resolve} + T_{MDS-MN} + T_{MN-xTR_3} + T_{xTR_3-MDS} + D_{Resolve} + T_{MDS-xTR_2} + T_{xTR_2-xTR_3}   \nonumber \\
&=& D_{DHCP} + 3T_{MN-MDS} + 2T_{MN-xTR_3} + 2T_{xTR_3-MDS} + 2D_{Resolve} +   \nonumber \\
& & T_{MDS-xTR_2} + T_{xTR_2-xTR_3}   \nonumber \\
&=& D_{DHCP} + 3* (3*D_{Link}) + 2*(3*D_{Link}) + 2*(2*D_{Link}) + 2*200ms +  \nonumber \\
& & 2*D_{Link} + 2*D_{Link} \nonumber \\
% &=& D_{DHCP} + 3* (3*2ms) + 2*(3*2ms) + 2*(2*2ms) + 2*200ms +  \nonumber \\
% & & 2*2ms + 2*2ms \nonumber \\
&=& D_{DHCP} + 23D_{Link} + 400 ms  \\
&=& D_{DHCP} + 446 ms \nonumber
\end{eqnarray}

The overall handover overhead $C_{overall}$ is:
\begin{eqnarray}
C_{overall} &=& C_{Register} + C_{Notify} + C_{SMR} + C_{invokeSMR} + C_{Reply} + C_{Request} + C_{Reply} \nonumber \\
&=& C_{Register} + C_{Notify} + C_{SMR} + 2C_{Request} + C_{Reply} + 2C_{Request} + C_{Reply} \nonumber \\
&=& 9 C
\end{eqnarray}

Not similar to the first two scenarios when $xTR_3$ directly sends the Invoke SMR back to the source of $SMR$ has smaller overall handover delay, this solution for the third scenario has bigger delay instead. It is caused by the double encapsulation in this scenario while the first two scenarios have only single encapsulation. When $xTR_3$ receives the $SMR$ from LISP-MN, it wants to sends Invoke $SMR$ to the LISP-MN for the mapping information of $<EID_{LISP-MN}, LRLOC_{LISP-MN}>$, but it does not know how to go LISP-MN, i.e., it lacks the mapping information of $<LRLOC_{LISP-MN}, RLOC_xTR2>$. Thus, it discards the $SMR$ and sends the $Map-Request$ to the mapping information first. Then, the mapping information of $<LRLOC_{LISP-MN}, RLOC_xTR2>$ is stored in its cache, and waits for the next $SMR$ so to send the Invoke SMR to the LISP-MN. The traffic schema is shown in Fig.~\ref{Mobility_double_encap_schema_SMR_askxTR_simplify}.
%-< FIGURE >--------------------------------------------------------------------
\begin{figure}[!th]
	\centering
	\includegraphics[width=0.8\textwidth]{Pics/Mobility_double_encap_schema_SMR_askxTR_simplify}
	\caption{Schema for LISP-MN in LISP-Site mobility}
	\label{Mobility_double_encap_schema_SMR_askxTR_simplify}
\end{figure}
%-< END FIGURE >--------------------------------------------------------------------

The overall handover delay $D_{overall}$ by sending the Invoke SMR to the source of $SMR$ in this scenario is as follows, where $T_{timeout\_SMR}$ is set to $1 s$ in the simulation:
\begin{eqnarray}
D_{overall} &=& D_{DHCP} + D_{Register} + D_{Notify} + D_{SMR} + T_{timeout_SMR} + D_{SMR} +  \nonumber \\
& & D_{invokeSMR} + D_{Reply} \nonumber \\
&=& D_{DHCP} + 2T_{MN-MDS} + 4T_{MN-xTR_3} + T_{timeout_SMR}\nonumber \\
&=& D_{DHCP} + 2* (3*D_{Link}) + 4*(3*D_{Link}) + T_{timeout\_SMR} \nonumber \\
% &=& D_{DHCP} + 2* (3*2ms) + 4*(3*2ms) + 1s \nonumber \\
&=& D_{DHCP} + 18D_{Link} + T_{timeout\_SMR}  \\
&=& D_{DHCP} + 1036 ms \nonumber
\end{eqnarray}

The overall handover overhead $C_{overall}$ is:
\begin{eqnarray}
C_{overall} &=& C_{Register} + C_{Notify} + C_{SMR} + 2C_{Request} + C_{Reply} + C_{SMR} +  \nonumber \\
& & C_{invokeSMR} + C_{Reply} \nonumber \\
&=& C_{Register} + C_{Notify} + 2C_{SMR} + 3C_{Request} + 2C_{Reply}  \nonumber \\
&=& 9 C
\end{eqnarray}

%%-< FIGURE >--------------------------------------------------------------------
%\begin{figure}[!th]
%	\centering
%	\includegraphics[width=0.8\textwidth]{Pics/Mobility_double_encap_schema_SMR_improving_simplify}
%	\caption{Schema for LISP-MN in LISP-Site mobility}
%	\label{Mobility_double_encap_schema_SMR_improving_simplify}
%\end{figure}
%%-< END FIGURE >--------------------------------------------------------------------
%If we do not consider the security issues, the handover schema can be simplified as shown in Fig.~\ref{Mobility_double_encap_schema_SMR_improving_simplify}.
%\begin{eqnarray}
%	D_{overall} &=& D_{DHCP} + D_{Register} + D_{Notify} + D_{SMR} + D_{Request} + D_{Reply} + D_{invokeSMR} + D_{Reply} \nonumber \\
%	&=& D_{DHCP} + 2T_{LISPMN-MDS} + D_{Resolve} + 3T_{LISPMN-xTR_3} \nonumber \\
%	&=& D_{DHCP} + 2* (3*2ms) + 200ms + 3*(3*2ms) \nonumber \\
%	&=& D_{DHCP} + 230 ms
%\end{eqnarray}
%where $D$ is the delay, $BI$ is Beacon Interval, subscriptions $Wi-Fi$, $DHCP$ and $SMR$ respectively refers to Wi-Fi association, DHCP procedure and LISP SMR. (Min value of handover delay = 1.300349, where packet sending interval = 0.02 s) 
%
%After several executions of simulation program, we observe that the overall handover delay changes by the various beacon intervals, in particular the Wi-Fi association delay depends on the different beacon intervals, whereas LISP SMR procedure always cost around $3s$. To get the lower bound of overall handover delay, we can ignore the Wi-Fi association delay when the beacon interval is $500ms$, and the latency due to DHCP procedure is always $1s$. Thus, adopting LISP-MN to conduct the host-based mobility takes at least $4s$. Compared to current most stable solution for host-based IP mobility management MIPv6, which latency including L2 and L3 in a real Wi-Fi testbed is around $3.68s$~\cite{vassiliou2010analysis}, LISP-MN has a higher delay caused by the double encapsulation mechanism introduced by LISP-MN behind LISP-Site. 
%
%During handover, CN can successfully receive packets from LISP-MN right after DHCP procedure being accomplished, but LISP-MN cannot receive the packets from CN until LISP SMR procedure is also finished. Thus, during DHCP procedure, all bi-directional transmitted packets are lost. To improve the performance, \cite{tang2017lisp} proposes a network-level LISP-MN solution, but has not validated their proposals neither in simulation nor in testbed. Our ns-3 implementation can be used to realize them.

Since both the MN and the border routers support LISP, the advantages of this scenario, i.e., LISP-MN in the LISP-Site, are: 
\begin{inparaenum}[1)]
	\item it can help to reduce the BGP routing table size;
	\item it is able to achieve seamless handover through different subnets.
\end{inparaenum}
However, same to the shortcomings for the first scenario, each LISP-MN needs a permanent IP address as its EID, which increases the burden of IPv4 address distribution. Each permanent EID and its RLOC needs register to the mapping system, which also increases the size of LISP mapping table. Besides, the numerical analysis indicates that the overall handover delay is much longer than the other two scenarios due to its double encapsulation.


%%-< SECTION >--------------------------------------------------------------------
%\section{Evaluations}
%\label{sec:ns3_evaluation}
%%-< FIGURE >--------------------------------------------------------------------
%\begin{figure}[!th]
%	\centering
%	\includegraphics[width=0.7\textwidth]{Pics/LISP_mobility_LISPMN_PacketInterval}
%	\caption{Impact of packet sending interval on handover delay}
%	\label{LISP_mobility_LISPMN_PacketInterval}
%\end{figure}
%%-< END FIGURE >--------------------------------------------------------------------
%
%%-< FIGURE >--------------------------------------------------------------------
%\begin{figure}[!th]
%	\centering
%	\includegraphics[width=0.7\textwidth]{Pics/LISP_mobility_xTR_PacketInterval}
%	\caption{Impact of packet sending interval on handover delay}
%	\label{LISP_mobility_xTR_PacketInterval}
%\end{figure}
%%-< END FIGURE >--------------------------------------------------------------------
%
%%-< FIGURE >--------------------------------------------------------------------
%\begin{figure}[!th]
%	\centering
%	\includegraphics[width=0.7\textwidth]{Pics/LISP_mobility_double_encap_PacketInterval}
%	\caption{Impact of packet sending interval on handover delay}
%	\label{LISP_mobility_double_encap_PacketInterval}
%\end{figure}
%%-< END FIGURE >--------------------------------------------------------------------

%-< SECTION >--------------------------------------------------------------------
\section{Conclusion and future work}
\label{sec:ns3_conclusion}
%\begin{itemize}
%    \item The validation of the implemented simulator
%    \item LISP-MN handover analysis
%    \item The potential of the implemented simulator
%\end{itemize}
As a promising technology for the future Internet architecture, LISP attracts more and more attention. There exist some LISP implementations, but they are proprietary or they do not support the extension of LISP mobility. Further, although measurements on LISP-testbeds can provide real time performance, due to the complicated topological structure, it is somewhat like a black box test, which hinders us to find the exact explanation for some results. This highlights the importance to have an open source simulator for LISP in particular to support LISP mobility functionality. In this chapter, based on an implementation of basic LISP on ns-3.24, we adapt it to ns-3.27 first (the latest version at the moment of writing), encode every bit in LISP Data Plane packets so that the Wireshark can resolve them and facilitate the researchers to deeply track the exchange of LISP packets, and finally we extend the LISP mobility features on it. As there are three methods to support mobility in LISP: host-based (i.e. LISP-MN), network-based (i.e., xTR), both host-based and network-based (i.e., LISP-MN behinds xTR) mobility. We numerically analyze the overall handover delay and the overhead of LISP control plane among them, compare the performance among them by listing their advantages and shortcomings. % The simulation results show that our implementation works well, and reveal the current LISP-MN proposal with a double encapsulation that has an high level delay during handover procedure. Our simulator can be a perfect choice to test the improvements of LISP-MN.

There are some directions for the further work. First we plan to validate the numerical analysis on the simulator. As Map-Versioning~\cite{rfc6834} is another Mapping Cache update mechanism, we can also compare the performance between it and $SMR$ that we present in this chapter by our simulator. Since the third scenario uses double encapsulation, which causes a big increase in the delay, we propose that the mapping system can differently processes Invoke SMR and the normal Map-Request. When mapping system receives an Invoke SMR, if it finds that the $RLOC$ of the queried EID is actually a $LRLOC$, e.g., the $LRLOC$ of LISP-MN in our third scenario, it then forwards the Map-Request not only to the LISP-MN, but also to the $xTR_2$, so that LISP-MN replies to the $xTR_3$ with the mapping information of $<EID_{LISP-MN}, LRLOC_{LISP-MN}>$, and $xTR_2$ replies to the $xTR_3$ with the mapping information of $<LRLOC_{LISP-MN}, RLOC_{xTR_2}>$. In this way, $xTR_3$ only needs query to the mapping system once, so the handover delay due to the LISP related procedure can reduce a lot.

